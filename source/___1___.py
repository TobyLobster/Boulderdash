# Disassembler

import sys
import logging
logger = logging.getLogger(__name__)
handler = logging.StreamHandler(stream=sys.stdout)
logger.addHandler(handler)

from commands import *
import acorn

config.set_label_references(False)
config.set_hex_dump(True)
#config.set_bytes_as_ascii(False)
config.set_show_autogenerated_labels(False)
config.set_show_cpu_state(False)
config.set_show_char_literals(False)
config.set_show_all_labels(False)

# NOTE:
#
#   Ranges here are *binary* NOT the *runtime* addresses as used everywhere else.
#   This is to make the addresses unique.
#
substitute_labels = {
    (0x2300, 0x23db): {
        "cell_above_left": "grid_column_counter",
    },
    (0x2400, 0x2500): {
        "tile_map_ptr_low": "tile_y",
        "tile_map_ptr_high": "tile_x",
    },
    (0x2626, 0x2689): {
        "cell_above_left": "neighbouring_cell_variable",
    },
    (0x295c, 0x2973): {
        "l0048": "remember_y",
    },
    (0x2a00, 0x2a28): {
        "real_keys_pressed": "x_loop_counter",
    },
    (0x2b00, 0x2b85): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
    },
    (0x2900, 0x2d45): {
        "loop_counter": "value_to_not_write_as_a_strip",
    },
    (0x2d00, 0x2d45): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
        "real_keys_pressed": "lower_nybble_value",
    },
    (0x22d3, 0x22d5): {
        "l0072": "dissolve_to_solid_flag",
    },
    (0x28c0, 0x28d3): {
        "l0072": "amount_to_increment_status_bar",
    },
    (0x2ebf, 0x2ec1): {
        "l0072": "dissolve_to_solid_flag",
    },
    (0x2f82, 0x2fb8): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
    },
    (0x3a00, 0x3b00): {
        "l006a": "timeout_until_demo_mode",
    },
}

# Common helper routines
class SubstituteLabels():
    def __init__(self, substitute_labels):
        self.substitute_labels = substitute_labels

        # Create the substitute labels but with inverted dictionaries
        self.inverse_labels = {}
        for pair in self.substitute_labels:
            dict = self.substitute_labels[pair]
            inv_dict = {v: k for k, v in dict.items()}
            self.inverse_labels[pair] = inv_dict

            # HACK: also make labels lXXXX, which seems redundant, but changes the way the label_maker suggestions works
            for key in dict:
                m = re.match("l([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])", key)
                if m:
                    addr = int(m.group(1), 16)
                    label(addr, key)

    def substitute_label_maker(self, addr, context, suggestion):
        for pair in self.substitute_labels:
            if context in range(pair[0], pair[1]):
                dict = self.substitute_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        # stop using the substitution if not in range
        for pair in self.inverse_labels:
            if context not in range(pair[0], pair[1]):
                dict = self.inverse_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        return suggestion

def ab(addr, add_blank=False):
    comment(addr, "ALWAYS branch", inline=True)
    if add_blank:
        blank(addr+2)

def ri(addr, message=""):
    if message == "":
        message = "redundant instruction"
    comment(addr, message, inline=True)

return_count = 1

def ret(addr):
    global return_count
    label(addr, f"return{return_count}")
    return_count += 1

unused_count = 1

def unused(addr):
    global unused_count
    label(addr, f"unused{unused_count}")
    unused_count += 1

def unused_entry(addr):
    global unused_count
    entry(addr, f"unused{unused_count}")
    unused_count += 1

def stars(addr, message=""):
    c = "*************************************************************************************"
    if message != "":
        c = c + "\n\n" + message + "\n\n*************************************************************************************"
    comment(addr, c)

def ten_by_four(addr, lab = None):
    blank(addr)
    ten_by_two(addr, lab)
    byte(addr+20, 10)
    byte(addr+30, 10)

def ten_by_two(addr, lab = None):
    if lab:
        label(addr, lab)
    byte(addr, 10)
    byte(addr+10, 10)

def message(start_addr, end_addr):
    string_length = 0
    for i in range(start_addr, end_addr):
        b = get_u8_binary(i)
        if b >= ord('A') and b <= ord('Z'):
            if string_length == 0:
                string_start = i
            string_length += 1
        else:
            if string_length > 0:
                string(string_start, string_length)
                string_length = 0
            byte(i)
            if b in sprites:
                expr(i, sprites)
    if string_length > 0:
        string(string_start, string_length)
        string_length = 0

load(0x1300, "original/___1___", "6502")

label(0x0046, "data_set_ptr_low")
label(0x0047, "data_set_ptr_high")
label(0x0059, "countdown_while_switching_palette")
label(0x005a, "tick_counter")
label(0x005c, "sub_second_ticks")
label(0x005d, "previous_direction_keys")
label(0x005e, "just_pressed_direction_keys")
label(0x0062, "keys_to_process")
label(0x0064, "neighbour_cell_contents")
label(0x0065, "demo_mode_tick_count")
label(0x0067, "demo_key_duration")
label(0x0069, "status_text_address_low")
label(0x006a, "map_rockford_end_position_addr_low")
label(0x006b, "map_rockford_end_position_addr_high")
label(0x006c, "diamonds_required")
label(0x006d, "time_remaining")
label(0x006f, "bonus_life_available")
label(0x0070, "map_rockford_current_position_addr_low")
label(0x0071, "map_rockford_current_position_addr_high")
label(0x0073, "cell_above_left")
label(0x0074, "cell_above")
label(0x0075, "cell_above_right")
label(0x0076, "cell_left")
label(0x0077, "cell_current")
label(0x0078, "cell_right")
label(0x0079, "cell_below_left")
label(0x007a, "cell_below")
label(0x007b, "cell_below_right")
label(0x007c, "real_keys_pressed")
label(0x0073, "grid_x")
label(0x0077, "loop_counter")
label(0x0079, "initial_cell_fill_value")
label(0x007e, "visible_top_left_map_x")
label(0x007f, "visible_top_left_map_y")
label(0x0080, "screen_addr2_low")
label(0x0081, "screen_addr2_high")
label(0x0082, "next_ptr_low")
label(0x0083, "next_ptr_high")
label(0x0084, "wait_delay_centiseconds")

label(0x0085, "tile_map_ptr_low")
label(0x0086, "tile_map_ptr_high")

label(0x0087, "cave_number")
label(0x0088, "row_counter")
label(0x0089, "difficulty_level")
label(0x008a, "screen_addr1_low")
label(0x008b, "screen_addr1_high")
label(0x008c, "ptr_low")
label(0x008d, "ptr_high")
label(0x008e, "sound_channel")
label(0x008f, "offset_to_sound")

# (Class SubstituteLabels is defined in common.py to implement the substitute labels)
s = SubstituteLabels(substitute_labels)
set_label_maker_hook(s.substitute_label_maker)

comment(0x1300, """
Caves: 20 caves total (16 main caves A-P plus four bonus caves Q-T)
Difficulty levels: 1-5

tile_map:

$00 = empty
$01 = earth
$02 = wall
$03 = titanium wall
$04 = diamond
$05 = rock
$06 = firefly
$07 = fungus
$08 = rockford
$09 = 4x4 earth square with firefly pacing inside
$0a = animated player exploding
$0b = Vertical strip (value above is filled down to the next $0b)
$0c = Horizontal strip
$0d = wall??
$0e = butterfly
$0f = player?

After post processing/during gameplay:
$08 = flashing titanium wall and earth before player appears
$18 = flashing exit
$21 = explosion frame #1
$11 = explosion frame #2
$0f = player looking out
$1f = player walking left
$2f = player walking right

$43 = explosion out effect #1
$33 = explosion out effect #2
$23 = explosion out effect #3
$13 = explosion out effect #4
""")

sprites = {
    0: "sprite_space",
    1: "sprite_boulder1",
    2: "sprite_boulder2",
    3: "sprite_diamond1",
    4: "sprite_diamond2",
    5: "sprite_diamond3",
    6: "sprite_diamond4",
    7: "sprite_titanium_wall1",
    8: "sprite_titanium_wall2",
    9: "sprite_box",

    10: "sprite_wall1",
    11: "sprite_wall2",
    12: "sprite_explosion1",
    13: "sprite_explosion2",
    14: "sprite_explosion3",
    15: "sprite_explosion4",
    16: "sprite_magic_wall1",
    17: "sprite_magic_wall2",
    18: "sprite_magic_wall3",
    19: "sprite_magic_wall4",

    20: "sprite_fungus1",
    21: "sprite_fungus2",
    22: "sprite_butterfly1",
    23: "sprite_butterfly2",
    24: "sprite_butterfly3",
    25: "sprite_firefly1",
    26: "sprite_firefly2",
    27: "sprite_firefly3",
    28: "sprite_firefly4",
    29: "sprite_earth1",

    30: "sprite_earth2",
    31: "sprite_pathway",
    32: "sprite_rockford_blinking1",
    33: "sprite_rockford_blinking2",
    34: "sprite_rockford_blinking3",
    35: "sprite_rockford_winking1",
    36: "sprite_rockford_winking2",
    37: "sprite_rockford_moving_down1",
    38: "sprite_rockford_moving_down2",
    39: "sprite_rockford_moving_down3",

    40: "sprite_rockford_moving_up1",
    41: "sprite_rockford_moving_up2",
    42: "sprite_rockford_moving_left1",
    43: "sprite_rockford_moving_left2",
    44: "sprite_rockford_moving_left3",
    45: "sprite_rockford_moving_left4",
    46: "sprite_rockford_moving_right1",
    47: "sprite_rockford_moving_right2",
    48: "sprite_rockford_moving_right3",
    49: "sprite_rockford_moving_right4",

    50: "sprite_0",
    51: "sprite_1",
    52: "sprite_2",
    53: "sprite_3",
    54: "sprite_4",
    55: "sprite_5",
    56: "sprite_6",
    57: "sprite_7",
    58: "sprite_8",
    59: "sprite_9",

    60: "sprite_white",
    61: "sprite_dash",
    62: "sprite_slash",
    63: "sprite_comma",
    64: "sprite_full_stop",
}

sprite_addr = {
    0: "sprite_addr_space",
    1: "sprite_addr_boulder1",
    2: "sprite_addr_boulder2",
    3: "sprite_addr_diamond1",
    4: "sprite_addr_diamond2",
    5: "sprite_addr_diamond3",
    6: "sprite_addr_diamond4",
    7: "sprite_addr_titanium_wall1",
    8: "sprite_addr_titanium_wall2",
    9: "sprite_addr_box",

    10: "sprite_addr_wall1",
    11: "sprite_addr_wall2",
    12: "sprite_addr_explosion1",
    13: "sprite_addr_explosion2",
    14: "sprite_addr_explosion3",
    15: "sprite_addr_explosion4",
    16: "sprite_addr_magic_wall1",
    17: "sprite_addr_magic_wall2",
    18: "sprite_addr_magic_wall3",
    19: "sprite_addr_magic_wall4",

    20: "sprite_addr_fungus1",
    21: "sprite_addr_fungus2",
    22: "sprite_addr_butterfly1",
    23: "sprite_addr_butterfly2",
    24: "sprite_addr_butterfly3",
    25: "sprite_addr_firefly1",
    26: "sprite_addr_firefly2",
    27: "sprite_addr_firefly3",
    28: "sprite_addr_firefly4",
    29: "sprite_addr_earth1",

    30: "sprite_addr_earth2",
    31: "sprite_addr_pathway",
    32: "sprite_addr_rockford_blinking1",
    33: "sprite_addr_rockford_blinking2",
    34: "sprite_addr_rockford_blinking3",
    35: "sprite_addr_rockford_winking1",
    36: "sprite_addr_rockford_winking2",
    37: "sprite_addr_rockford_moving_down1",
    38: "sprite_addr_rockford_moving_down2",
    39: "sprite_addr_rockford_moving_down3",

    40: "sprite_addr_rockford_moving_up1",
    41: "sprite_addr_rockford_moving_up2",
    42: "sprite_addr_rockford_moving_left1",
    43: "sprite_addr_rockford_moving_left2",
    44: "sprite_addr_rockford_moving_left3",
    45: "sprite_addr_rockford_moving_left4",
    46: "sprite_addr_rockford_moving_right1",
    47: "sprite_addr_rockford_moving_right2",
    48: "sprite_addr_rockford_moving_right3",
    49: "sprite_addr_rockford_moving_right4",

    50: "sprite_addr_0",
    51: "sprite_addr_1",
    52: "sprite_addr_2",
    53: "sprite_addr_3",
    54: "sprite_addr_4",
    55: "sprite_addr_5",
    56: "sprite_addr_6",
    57: "sprite_addr_7",
    58: "sprite_addr_8",
    59: "sprite_addr_9",

    60: "sprite_addr_white",
    61: "sprite_addr_dash",
    62: "sprite_addr_slash",
    63: "sprite_addr_comma",
    64: "sprite_addr_full_stop",
    65: "sprite_addr_A",
    66: "sprite_addr_B",
    67: "sprite_addr_C",
    68: "sprite_addr_D",
    69: "sprite_addr_E",

    70: "sprite_addr_F",
    71: "sprite_addr_G",
    72: "sprite_addr_H",
    73: "sprite_addr_I",
    74: "sprite_addr_J",
    75: "sprite_addr_K",
    76: "sprite_addr_L",
    77: "sprite_addr_M",
    78: "sprite_addr_N",
    79: "sprite_addr_O",

    80: "sprite_addr_P",
    81: "sprite_addr_Q",
    82: "sprite_addr_R",
    83: "sprite_addr_S",
    84: "sprite_addr_T",
    85: "sprite_addr_U",
    86: "sprite_addr_V",
    87: "sprite_addr_W",
    88: "sprite_addr_X",
    89: "sprite_addr_Y",

    90: "sprite_addr_Z",

    96: "sprite_addr_titanium_wall1",
}

for i in sprites:
    constant(i, sprites[i])

ranges = [(0x1ee0, 0x1ef0),
          (0x1ef3, 0x1efa),
          (0x1efb, 0x1f00),
          (0x1f32, 0x1f37),
          (0x1f38, 0x1f46),
          (0x1f4c, 0x1f52),
          (0x1f55, 0x1f56),
          (0x1f57, 0x1f5a),
          (0x3200, 0x3214),
          (0x321a, 0x3220),
          (0x3223, 0x3225),
          (0x3226, 0x323c),
          (0x3242, 0x3248),
          (0x324b, 0x324d),
          (0x324e, 0x3258),
          (0x325c, 0x3264),
          (0x3265, 0x3266),
          (0x3267, 0x3268),
          (0x3269, 0x326a),
          (0x326b, 0x326c),
          (0x326d, 0x3271),
          (0x3272, 0x3273),
          (0x3274, 0x3275),
          (0x3276, 0x3277),
          (0x3278, 0x327a),
          (0x3280, 0x3284),
          (0x328a, 0x328d),
          (0x3291, 0x3292),
          (0x3296, 0x3297),
          (0x329d, 0x32a1),
          (0x32ae, 0x32af),
          (0x32b3, 0x32b4),
          (0x32b5, 0x32b6),
          (0x32b7, 0x32b8),
          (0x32b9, 0x32bb),
          (0x32bc, 0x32bd),
          (0x32be, 0x32c1),
          (0x32c2, 0x32c3),
          (0x32c4, 0x32c5),
          (0x32c6, 0x32c7),
          (0x32cb, 0x32cc),
          (0x32d1, 0x32d3),
          (0x32d5, 0x32d6),
          (0x32dc, 0x32e4),
          (0x32e8, 0x3300),
          (0x5028, 0x502a),
          (0x5030, 0x5034),
          (0x503a, 0x503c),
          (0x506e, 0x5074),
          (0x5077, 0x5079),
          (0x507a, 0x507c),
          ]

constant(0x0, "map_space")
constant(0x1, "map_earth")
constant(0x2, "map_wall")
constant(0x3, "map_titanium_wall")
constant(0x4, "map_diamond")
constant(0x5, "map_rock1")
constant(0x6, "map_exit")
constant(0x7, "map_fungus")
constant(0x8, "map_player1")
constant(0x9, "map_earth_plus_firefly_4x4")
constant(0xa, "map_explosion")
constant(0xb, "map_vertical_strip")
constant(0xc, "map_horizontal_strip")
constant(0xd, "map_rock2")       # second type
constant(0xe, "map_butterfly")
constant(0xf, "map_player2")     # second type?

for r in ranges:
    for i in range(r[0], r[1]):
        byte(i)
        expr(i, sprites)

addrs = [0] * 106
for i in range(0, 105):
    if i in sprite_addr:
        name  = sprite_addr[i]
    else:
        name  = "sprite_addr_" + str(i)
    addr = get_u8_binary(0x2000+i) + 256*get_u8_binary(0x2080+i)
    if addr not in addrs:
        addrs[i] = addr
    label(addr, name)
    byte(0x2000+i)
    byte(0x2080+i)
    expr(0x2000+i, make_lo(name))
    expr(0x2080+i, make_hi(name))

unused(0x2069)
byte(0x2069, 0x2080-0x2069)
unused(0x20e9)
byte(0x20e9, 0x2100-0x20e9)

i = 1
while i < len(addrs):
    length = addrs[i] - addrs[i-1]
    utils.warn(i)
    if length > 0:
        byte(addrs[i-1], length)
    i=i+1
for i in range(0x2228, 0x2228+8):
    inkey_key = get_u8_binary(i)
    constant(inkey_key, acorn.inkey_enum[inkey_key])
    expr(i, acorn.inkey_enum)
    byte(i)

data_sets_present = []
for addr in range(0x4ce0, 0x4cf4):
    if get_u8_binary(addr) < 128:
        data_sets_present.append(get_u8_binary(addr))

basics = {}
j = 0
for data_set in range(len(data_sets_present)):
    addr = 0x4cf4 + data_set * 20
    label(addr, "data_set_"+ str(j))
    j += 1

    for difficulty in range(5):
        byte(addr, 4)
        basics_addr = 0x4e00 + get_u8_binary(addr)
        map_start = get_u8_binary(addr + 1)
        if map_start >= 128:
            basics_addr += 0x100
            map_start = map_start & 127
        map_start += 0x5000
        patch_addr = get_u8_binary(addr + 2) + 256*get_u8_binary(addr + 3)
        comment(addr, f"Difficulty {difficulty+1}: basics={hex(basics_addr)}, map_start={hex(map_start)}, patch_addr={hex(patch_addr)}", inline=True)
        addr += 4
        if not basics_addr in basics:
            basics[basics_addr] = f"basics_for_data_set_{j}_difficulty_{difficulty+1}"
            label(basics_addr, basics[basics_addr])

blank(0x4df8)

constant(20, "total_caves")
constant(0xac, "opcode_ldy_abs")
constant(0xb9, "opcode_lda_abs_y")
constant(0xca, "opcode_dex")
constant(0xe8, "opcode_inx")

label(0x0c00, "grid_of_screen_sprites")

label(0x1300, "initial_clock_value")

label(0x1e70, "set_clock_value")
unused(0x1ee0)
blank(0x1ee0)

byte(0x1f00, 15)
unused(0x1f0f)
byte(0x1f0f, 35)
blank(0x1f32)
string(0x1f56, 1)
blank(0x1f5a)
byte(0x1f5a, 38)
label(0x1f80, "cell_type_to_sprite")
message(0x1f80, 0x2000)
label(0x1f87, "two_state_animated_sprites1")
label(0x1fc7, "two_state_animated_sprites2")
for i in range(0x1f80, 0x2000, 16):
    blank(i)

blank(0x2000)
label(0x2000, "sprite_addresses_low")
label(0x2007, "sprite_titanium_addressA")
label(0x2060, "sprite_titanium_addressB")
label(0x2080, "sprite_addresses_high")
unused(0x20df)

byte(0x2120, 16)
label(0x2120, "cell_value_to_fill_vertically")
blank(0x2130)
label(0x2130, "some_array_of_cells")
label(0x2140, "another_array_of_cells")
label(0x2150, "index_to_cell_type")
byte(0x2156, 9)
byte(0x21c0, 16)
label(0x21c0, "handler_table_low")
byte(0x21d0, 12)
label(0x21d0, "handler_table_high")
byte(0x21dc, 4)
label(0x26c3, "fill_with_a")

handlers = { 0x22a5: "handler_0123",
             0x2500: "handler_firefly",
             0x259e: "handler_7",
             0x26e3: "handler_8",
             0x2bca: "handler_9",
             0x26e3: "handler_10",
             0x23e0: "handler_for_vertical_strip",
             0x23f0: "handler_for_horizontal_strip",
             0x26ae: "handler_13",
             0x2600: "handler_15" }

for addr in handlers:
    label(addr, handlers[addr])

for i in range(16):
    addr1 = 0x21c0+i
    addr2 = 0x21d0+i
    addr = get_u8_binary(addr1) + 256*get_u8_binary(addr2)
    if addr != 0:
        entry(addr)
        if addr in handlers:
            expr(addr1, make_lo(handlers[addr]))
            expr(addr2, make_hi(handlers[addr]))

label(0x2200, "neighbouring_cell_variable_from_direction_index")
byte(0x2200)
expr(0x2200, "cell_right")
byte(0x2201)
expr(0x2201, "cell_left")
byte(0x2202)
expr(0x2202, "cell_above")
byte(0x2203)
expr(0x2203, "cell_below")
label(0x2224, "rockford_cell_value_for_direction")
label(0x2228, "inkey_keys_table")
blank(0x2230)
unused(0x2230)
entry(0x2230)
label(0x2238, "increment_ptr_and_clear_carry")
label(0x223e, "skip_increment")
label(0x2240, "add_a_to_ptr")
ret(0x2249)
label(0x224a, "reverse_nybbles_and_add_one")
comment(0x2256, "Clears the entire map to initial_cell_fill_value.\nClears the visible grid to $ff", indent=1)
label(0x2256, "clear_map_and_grid")
expr(0x2257, make_lo("map_row_1-1"))
expr(0x225b, make_hi("map_row_1-1"))
label(0x2276, "increment_ptr_using_40_bytes_out_of_every_64")
label(0x2292, "reset_grid_of_sprites")
label(0x2296, "reset_grid_of_sprites_loop")
label(0x229e, "clear_backwards_status_bar_loop")
entry(0x22a5)
comment(0x22ad, "cell is in the range $90-$9f, so we look up the replacement in a table", indent=1)
label(0x22b1, "not_in_range_so_change_nothing")
expr(0x22b4, make_lo("map_row_0"))
expr(0x22b8, make_hi("map_row_0"))
decimal(0x22bc)
label(0x22bd, "loop_over_rows")
label(0x22dc, "skip_to_next_row")
unused(0x22f9)
entry(0x22f9)
comment(0x22fb, "sta $2c16", indent=1)
nonentry(0x22fb)
entry(0x22fe)
unused(0x22ff)
entry(0x22ff)

label(0x2300, "draw_grid_of_sprites")
expr(0x2307, make_hi("screen_addr_row_6"))
expr(0x230b, make_lo("screen_addr_row_6"))
expr(0x230d, "opcode_lda_abs_y")
expr(0x2312, make_lo("grid_of_screen_sprites"))
expr(0x231a, make_hi("grid_of_screen_sprites"))
expr(0x2322, make_lo("zeroed_status_bar"))
ab(0x2323, True)
label(0x2325, "draw_grid_at_regular_screen_address")
expr(0x2326, make_lo("start_of_grid_screen_address"))
expr(0x2328, make_hi("start_of_grid_screen_address"))
label(0x2329, "draw_grid")
expr(0x232c, make_hi("backwards_status_bar"))
expr(0x232e, make_lo("backwards_status_bar"))
label(0x233b, "instruction_for_self_modification")
label(0x233c, "status_text_address_high")
expr(0x233c, make_hi("tile_map"))
expr(0x2340, "opcode_ldy_abs")
comment(0x2344, "X is the column counter", indent=1)
decimal(0x2345)
label(0x234c, "draw_grid_loop")
label(0x2350, "grid_draw_row_loop")
comment(0x2355, "Y=9 indicates the titanium wall", indent=1)
comment(0x2357, "this next instruction is either:\n    'ldy cell_type_to_sprite' [which in this context is a NOP] OR \n    'lda cell_type_to_sprite,y'\nas set by self-modifying code above", indent=1)
label(0x2357, "load_instruction")
label(0x235b, "compare_instruction")
label(0x235c, "grid_compare_address_low")
label(0x235d, "grid_compare_address_high")
label(0x2360, "write_instruction")
label(0x2361, "grid_write_address_low")
label(0x2362, "grid_write_address_high")
comment(0x2375, "Each sprite is two character rows tall. screen_addr2_low/high is the destination screen address for the second character row of the sprite", indent=1)
comment(0x2381, "This next loop draws a single sprite in the grid.\nIt draws two character rows at the same time, with 16 bytes in each row.", indent=1)
label(0x2383, "draw_sprite_loop")
label(0x23a9, "skip_draw_sprite")
comment(0x23a9, "move the screen pointer on 16 pixels to next column", indent=1)
label(0x23b4, "skip_high_byte")
decimal(0x23b9)
comment(0x23bc, "return if we have drawn all the rows (X=0)", indent=1)
comment(0x23bf, "move screen pointer on to next row of sprites (two character rows)", indent=1)
comment(0x23cc, "move tile pointer on to next row (64 bytes)", indent=1)

ret(0x23db)
unused(0x23dc)
comment(0x23e0, "Handler for filling in a vertical strip. Set the cells between $0b's to the value above the first $0b.", indent=1)
label(0x23e8, "replace_cell_below")
comment(0x23ea, "copy cell above to current cell, clearing top bit", indent=1)
entry(0x23f9)
unused(0x23fe)
expr(0x242a, "map_diamond")

label(0x2400, "update_map")
comment(0x2400, "set branch offset (self modifying code)", indent=1)
expr(0x2401, "update_map_space - after_branch")
ab(0x2402, True)
label(0x2404, "preprocess_map")
comment(0x2404, "set branch offset (self modifying code)", indent=1)
expr(0x2405, "mark_cell_above_as_processed_and_move_to_next_cell - after_branch")
label(0x2406, "set_branch_offset")
comment(0x2409, "twenty rows", indent=1)
decimal(0x240a)
expr(0x240e, make_hi("map_row_0"))
expr(0x2412, make_lo("map_row_0"))
comment(0x2417, "loop through the twenty rows of map", indent=1)
label(0x2417, "tile_map_y_loop")
comment(0x2417, "38 columns (cells per row)", inline=1)
decimal(0x2418)
comment(0x241f, "move to the next cell", indent=1)
comment(0x2420, "read current cell contents into X", indent=1)
label(0x2423, "tile_map_x_loop")
comment(0x2423, "loop through the 38 cells in a row of map", indent=1)
comment(0x2423, "read next cell contents into cell_right", indent=1)
comment(0x242d, "if current cell is already processed (top bit set), then skip to next cell", indent=1)
comment(0x2430, "mark current cell as processed (set top bit)", indent=1)
comment(0x2433, "the lower four bits are the type, each of which has a handler to process it", indent=1)
comment(0x2439, "if we have an empty cell, branch (destination was set depending on where we entered this routine)", indent=1)
label(0x2439, "branch_instruction")
label(0x243a, "branch_offset")
label(0x243b, "after_branch")
comment(0x2444, "read cells into cell_above and cell_below variables", indent=1)
comment(0x2450, "call the handler for the cell based on the type (0-15)", indent=1)
comment(0x2453, "the handler may have changed the surreounding cells. store the new cell down", indent=1)
comment(0x2459, "store the new cell up", indent=1)
ab(0x245f, True)
label(0x2461, "mark_cell_above_as_processed_and_move_to_next_cell")
label(0x2467, "move_to_next_cell")
comment(0x2469, "store the new cell left back into the map", indent=1)
comment(0x246f, "update cell_left with the current cell value (in X)", indent=1)
comment(0x2471, "update the current cell value x from the cell_right variable", indent=1)
comment(0x2473, "move ptr to next position", indent=1)
comment(0x2475, "loop back for the rest of the cells in the row", indent=1)
comment(0x2479, "store the final previous_cell for the row", indent=1)
comment(0x247d, "move ptr to the start of the next row. Stride is 64, 38 entries done, so remainder to add is 64-38=26", indent=1)
decimal(0x247e)
comment(0x2482, "loop back for the rest of the rows", indent=1)
comment(0x2486, "clear top bit in final row", indent=1)
decimal(0x2487)
label(0x2488, "clear_top_bit_on_final_row_loop")
comment(0x2493, "clear top bit on end position", indent=1)
label(0x249a, "update_map_space")
comment(0x249a, "get cell below", indent=1)
comment(0x24a0, "check current cell", indent=1)
label(0x24a7, "not_c0_or_above")
label(0x24d0, "set_to_space")
ab(0x24d2, True)
label(0x24d4, "space_below_is_also_a_space")
comment(0x24d4, "set bit six of the cell below to indicate cell above is also a space")
ab(0x24d9, True)
label(0x24db, "process_c0_or_above")
comment(0x24dc, "look up table based on type", indent=1)
comment(0x24e4, "store in cell below", indent=1)
label(0x24e8, "dont_store_below")
expr(0x24ec, "l004b")
comment(0x24ee, "store $4b or $4c in location $4b or $4c. Flashing animation?", indent=1)
comment(0x24f1, "mask off the top two bits for the current cell value", indent=1)
unused(0x24f7)

expr(0x2507, "cell_above_left-1")
ri(0x2509)
label(0x250b, "unnecessary_branch")
expr(0x2544, make_lo("another_array_of_cells"))
expr(0x254a, make_lo("some_array_of_cells"))
comment(0x2550, "read above left cell", indent=1)
comment(0x2556, "reset current cell to zero", indent=1)
comment(0x2558, "read above right cell", indent=1)
comment(0x255e, "read below left cell", indent=1)
comment(0x2564, "read below right cell", indent=1)
comment(0x256a, "loop 9 times", indent=1)
expr(0x256d, "cell_above_left-1")
expr(0x2577, "cell_above_left-1")
comment(0x257b, "write to above left cell", indent=1)
comment(0x2583, "write to above right cell", indent=1)
comment(0x2589, "write to below left cell", indent=1)
comment(0x258f, "write to below right cell", indent=1)
entry(0x2598)
unused(0x2598)
ret(0x25f5)
unused_entry(0x25f6)
unused_entry(0x25fc)

label(0x260e, "check_for_direction_key_pressed")
label(0x2626, "direction_key_pressed")
label(0x262b, "get_direction_index_loop")
comment(0x263b, "read cell contents from the given neighbouring cell variable y", indent=1)
label(0x2667, "check_for_return_pressed")
comment(0x266d, "return (and direction) is pressed", indent=1)
ab(0x2687, True)
label(0x2689, "read_keys")
label(0x2691, "read_keys_loop")
unused(0x26ab)
unused(0x26df)
expr(0x26fa, make_lo("status_bar_sprite_numbers"))
ret(0x26fd)
unused(0x26fe)

label(0x2700, "start_gameplay")
label(0x2735, "update_demo_mode")
expr(0x2736, make_lo("status_bar_sprite_numbers"))
expr(0x273e, make_lo("scrolling_pause_text"))
comment(0x2777, "decrement time remaining", indent=1)
expr(0x2781, make_lo("out_of_time_message"))
ret(0x27ef)
unused(0x27f0)
byte(0x27f0,16)

#label(0x2800, "update_rockford_animation")
unused(0x2852)
byte(0x2852, 14)
label(0x2860, "read_keys_and_resolve_direction_keys")
comment(0x2863, "just get the direction keys (top nybble)", indent=1)
comment(0x2869, "look for any changes of direction. If so use the just pressed directions as input", indent=1)
comment(0x286d, "no new directions were pressed, so use the previous directions from last time.", indent=1)
label(0x2872, "direction_keys_changed")
comment(0x2876, "nothing was just pressed, so just use the currently pressed keys", indent=1)
label(0x2877, "store_active_direction_keys")
comment(0x287a, "remember the special (non-direction keys) only", indent=1)
comment(0x2880, "recall the active direction keys, and combine with the special keys", indent=1)
unused(0x288a)
label(0x2898, "increment_status_bar_number")
expr(0x28a3, "sprite_0")
expr(0x28b1, "sprite_0")
label(0x28c0, "add_a_to_status_bar_number_at_y")
unused(0x28d4)
byte(0x28d4, 44)
label(0x28aa, "decrement_status_bar_number")

label(0x2900, "prepare_level")
comment(0x2910, "high nybbles in the cave colour arrays store the sprite to use for three basic block types. copy them into cell_above_left/cell_above/cell_above_right", indent=1)
label(0x2914, "loop_three_times")
expr(0x291c, "cell_above_left-1")
comment(0x291d, "add number of caves to Y, in order to get next block type", indent=1)
expr(0x2920, "total_caves")
comment(0x2922, "increment loop counter X", indent=1)
comment(0x2927, "look up which data set needed from the cave number", indent=1)
comment(0x292f, "start with ptr = data_sets", indent=1)
expr(0x2930, make_lo("data_sets"))
expr(0x2934, make_hi("data_sets"))
comment(0x2937, "Loop counter X is data set number.\nAdd X * twenty bytes to pointer to get to 'data_set_X' address", indent=1)
label(0x293a, "add_twenty_times_x_loop")
expr(0x293b, "total_caves")
label(0x2942, "got_data_set_X_address")
comment(0x2946, "set offset in Y = 4*(difficulty level-1)", indent=1)
comment(0x2951, "set next_ptr = $4e00+?ptr, and if top bit of (ptr?1) is set, increment high byte", indent=1)
comment(0x2959, "use the lower seven bits of (ptr?1) as ptr_low", indent=1)
comment(0x2964, "set ptr_low = (ptr?1) AND &7F", indent=1)
label(0x2964, "store_ptr_low_and_fill_with_basics")
comment(0x2969, "reset ptr to the start of the data_set_X", indent=1)
comment(0x2971, "recall Y and read the next two bytes as an address. Can be zero. For details?", indent=1)
label(0x2982, "add_strips")
expr(0x2983, make_lo("strip_data"))
expr(0x2987, make_hi("strip_data"))
comment(0x298a, "get value to skip when writing strips to the map", indent=1)
label(0x2995, "find_strip_data_for_cave_loop")
nonentry(0x299a)
nonentry(0x299c)
label(0x29a1, "found_strip_data_for_cave")
label(0x29ac, "set_palette")
label(0x29b0, "set_palette_loop")
unused_entry(0x29c3)
nonentry(0x29d2)
comment(0x29d2, "beq $299c", indent=1)
ret(0x29d4)
unused_entry(0x29d5)
nonentry(0x29dd)
byte(0x29dd, 2)
comment(0x29dd, "bne $299a", indent=1)
entry(0x29df)
unused(0x29e0)

label(0x2a00, "increment_map_ptr")
label(0x2a17, "skip_increment_high_byte2")
ret(0x2a19)
label(0x2a1a, "set_ptr_to_start_of_map")
expr(0x2a1b, make_lo("map_row_1"))
label(0x2a1c, "set_ptr_high_to_start_of_map_with_offset_a")
label(0x2a1e, "set_ptr_high_to_start_of_map")
expr(0x2a1f, make_hi("map_row_1"))
label(0x2a29, "palette_block")
byte(0x2a29)
label(0x2a2a, "palette_block+1")
byte(0x2a2a)
byte(0x2a2b)
byte(0x2a2c)
byte(0x2a2d)
label(0x2a2e, "increment_next_ptr")
label(0x2a35, "set_palette_colour_ax")
label(0x2a4d, "reset_clock")
label(0x2a56, "animate_flashing_spaces_and_check_for_bonus_life")
stars(0x2a56)
comment(0x2a56, "")
comment(0x2a56, """Animate the flashing spaces on the grid.\nCalculate and set palette colour 3 over a number of frames
Also checks for awarding a bonus life.

Sequence of colours to show.
countdown_while_changing_palette    physical colour to set
    7                                       7 (white)
    6                                       6 (cyan)
    5                                       5 (magenta)
    4                                       3 (yellow)
    3                                       7 (white)
    2                                       6 (cyan)
    1                                       5 (magenta)
    0                                       -
""")

comment(0x2a68, "set logical colour three", indent=1)
label(0x2a6a, "skip_setting_physical_colour_to_three")
comment(0x2a71, "restore to spaces", indent=1)
blank(0x2a79)
comment(0x2a79, "a bonus life is awarded every 500 points", indent=1)
label(0x2a79, "check_for_bonus_life")
expr(0x2a7d, "sprite_0")
expr(0x2a81, "sprite_5")
label(0x2a89, "zero_or_five_in_hundreds_column")
label(0x2a8b, "check_for_non_zero_in_top_digits")
expr(0x2a8f, "sprite_0")
label(0x2a9c, "non_zero_digit_found_in_hundreds_column_or_above")
comment(0x2ab0, "show bonus life text (very briefly)", indent=1)
expr(0x2ab1, make_lo("bonus_life_text"))
ret(0x2ab4)
label(0x2ab5, "draw_big_rockford")
stars(0x2ab5)
expr(0x2ab6, make_hi("big_rockford_destination_screen_address"))
expr(0x2aba, make_lo("big_rockford_destination_screen_address"))
expr(0x2abe, make_hi("big_rockford_sprite"))
label(0x2ac3, "draw_big_rockford_loop")
label(0x2aca, "check_if_byte_is_an_rle_byte_loop")
ab(0x2ad2, True)
label(0x2ad4, "get_repeat_count")
label(0x2adc, "copy_x_bytes_in_rle_loop")
label(0x2ae6, "skip_inc_high")
ab(0x2ae9, True)
label(0x2aeb, "get_next_ptr_byte")
ret(0x2af3)
unused(0x2af4)
blank(0x2af8)
label(0x2af8, "rle_bytes_table")
byte(0x2af8, 7)
blank(0x2aff)
unused(0x2aff)
comment(0x2aa0, "award bonus life", indent=1)
comment(0x2aa4, "set sprite for space to pathway", indent=1)
expr(0x2aa5, "sprite_pathway")
comment(0x2aa9, "start animating colour three", indent=1)
comment(0x2aad, "add one to the MEN count", indent=1)

stars(0x2b00)
label(0x2b00, "map_address_to_map_xy_position")
label(0x2b15, "map_xy_position_to_map_address")
comment(0x2b2c, "Scrolls the map by setting the tile_map_ptr and visible_top_left_map_x and y")
label(0x2b2c, "update_map_scroll_position")
decimal(0x2b3d)
decimal(0x2b41)
label(0x2b45, "check_for_need_to_scroll_left")
label(0x2b4e, "check_for_need_to_scroll_down")
label(0x2b5e, "check_for_need_to_scroll_up")
label(0x2b67, "check_for_bonus_levels")
comment(0x2b6d, "bonus level is always situated in top left corner", indent=1)
label(0x2b71, "skip_bonus_level")
unused(0x2b85)
label(0x2b90, "wait_for_13_centiseconds_and_read_keys")
label(0x2b92, "wait_for_a_centiseconds_and_read_keys")
label(0x2b94, "wait_for_centiseconds_and_read_keys")
label(0x2b98, "wait_loop")
unused(0x2bc0)

for i in range(0, 9):
    byte(0x2c00+i*4, 4)

blank(0x2c00)
comment(0x2c00, "Sound data packed into single bytes: channel, amplitude, pitch, duration")
label(0x2c00, "in_game_sound_data")
acorn.sound(0x2c24, "in_game_sound_block")
label(0x2c26, "in_game_sound_amplitude")
label(0x2c27, "in_game_sound_amplitude+1")
label(0x2c28, "in_game_sound_pitch")
label(0x2c2a, "in_game_sound_duration")
comment(0x2c2c, "If X is negative, then play sound (X AND 127) with pitch Y.\nIf X is non-negative, play sound X with default pitch.")
label(0x2c2c, "play_sound_x_pitch_y")
label(0x2c31, "skip_using_default_pitch1")
comment(0x2c38, "sound 6 also plays sound 7", indent=1)
label(0x2c3d, "play_raw_sound_x_pitch_y")
expr(0x2c4d, "in_game_sound_data+1")
label(0x2c59, "skip_negative_amplitude")
comment(0x2c5c, "use default pitch", indent=1)
expr(0x2c5d, "in_game_sound_data+2")
label(0x2c5f, "skip_using_default_pitch2")
expr(0x2c63, "in_game_sound_data+3")
unused(0x2c71)
comment(0x2c92, "play rising pitch as time up is approaching", indent=1)
expr(0x2ca6, "in_game_sound_data+2")
ret(0x2cef)
unused(0x2cf0)

label(0x2d00, "write_strips")
comment(0x2d12, "remember value", indent=1)
comment(0x2d13, "get repeat count (from high nybble)", indent=1)
label(0x2d1e, "write_strip_loop")
comment(0x2d20, "a value of 10 means move to the next row", indent=1)
comment(0x2d24, "if it's this cave's skip value, then don't write to the map", indent=1)
label(0x2d2a, "skip_write_to_map")
comment(0x2d2a, "move the map position one to the right, wrapping to the next row if needed", indent=1)
decimal(0x2d2f)
ri(0x2d30)
label(0x2d32, "move_to_next_row")
decimal(0x2d39)
label(0x2d3c, "get_map_address")
ab(0x2d42, True)
ret(0x2d44)
unused(0x2d45)
label(0x2d50, "add_patches")
expr(0x2d51, make_lo("map_row_1-1"))
comment(0x2d5a, "remember the byte read", indent=1)
comment(0x2d5b, "the top five bits are the offset into the map to change.", indent=1)
comment(0x2d60, "add X to ptr (where we only use 40 out of every 64 bytes for the map)", indent=1)
label(0x2d60, "add_X_to_map_ptr_loop")
comment(0x2d68, "recall the byte, and isolate the bottom three bits.", indent=1)
comment(0x2d6b, """0 = store value 0
1 = skip this byte (no change)
2 = store value 2
3 = terminator
4 = store value 4
5 = store value 5
6 = store value 6
7 = store value 1""", indent=1)
label(0x2d7f, "pull_a_and_return")
unused(0x2d81)
label(0x2d90, "fill_with_basics")
comment(0x2d93, "read byte from stage. This is done 200 times (40x20 cells, 4 cells per byte)", indent=1)
label(0x2d93, "read_next_byte_loop")
comment(0x2d97, "increment to next byte", indent=1)
label(0x2d9d, "skip_increment_high_byte1")
comment(0x2da1, "Extract the top two bits of the stage byte. Each pair of bits holds a type to write into the cell. We shift down six times to get the index, and put the result in X.", indent=1)
label(0x2da1, "loop_for_each_byte")
comment(0x2da9, "if the index is zero, don't write to the map.", indent=1)
comment(0x2dab, "X=1,2 or 3. Look up the sprite to store in the cell (in the map).", indent=1)
expr(0x2dac, "cell_above_left-1")
comment(0x2db4, "recall the byte and shift twice to start reading the next pair of bits", indent=1)
ab(0x2dbb, True)
label(0x2dbd, "pull_and_return2")
unused_entry(0x2dbf)
unused(0x2dca)
comment(0x2dcf, "bpl $2da6\nbmi $2d98", indent=1)
nonentry(0x2dcf)
byte(0x2dcf, 2)
nonentry(0x2dd1)
ab(0x2dd1, True)
unused(0x2dd3)
nonentry(0x2dd3)
byte(0x2de9, 3)

expr(0x2e0b, make_lo("players_and_men_status_bar"))
expr(0x2e13, make_lo("bonus_life_text"))
expr(0x2e1b, make_lo("scrolling_pause_text"))
comment(0x2e2c, "don't process horizontal strips", indent=1)
expr(0x2e2f, "handler_table_high+12")
comment(0x2e34, "process horizontal strips", indent=1)
expr(0x2e35, ">handler_for_horizontal_strip")
expr(0x2e37, "handler_table_high+12")
comment(0x2e3c, "map complete: draw titanium wall borders", indent=1)
comment(0x2e3f, "loop over all rows", indent=1)
decimal(0x2e40)
label(0x2e41, "write_left_and_right_borders_loop")
decimal(0x2e42)
comment(0x2e43, "write the right hand border", indent=1)
label(0x2e48, "hide_cells_loop")
comment(0x2e51, "write the left hand border", indent=1)
comment(0x2e5d, "write the top and bottom borders", indent=1)
decimal(0x2e60)
label(0x2e61, "write_top_and_bottom_borders_loop")
expr(0x2e80, "sprite_0")
expr(0x2e8a, make_lo("game_over_text"))
expr(0x2e93, "sprite_1")
label(0x2ebd, "play_scren_dissolve_to_solid")
label(0x2ebf, "play_screen_dissolve_effect")
label(0x2ec9, "screen_dissolve_loop")
unused(0x2ee4)
byte(0x2ee4, 28)

expr(0x2f0a, "sprite_0")
expr(0x2f15, "sprite_0")
expr(0x2f34, "sprite_0")
ret(0x2f47)
unused(0x2f48)
label(0x2f50, "initialise_stage")
decimal(0x2f51)
label(0x2f59, "empty_status_bar_loop")
comment(0x2f64, "show initial diamond score amount on status bar", indent=1)
comment(0x2f6c, "show cave letter on status bar", indent=1)
comment(0x2f73, "show difficulty level on status bar", indent=1)
expr(0x2f77, "sprite_0")
comment(0x2f7b, "TODO: what is this?", indent=1)
comment(0x2f82, "put the end tile on the map", indent=1)
comment(0x2f9d, "put the start tile on the map", indent=1)
comment(0x2fb8, "add 40 to the cave number for each difficulty level above one", indent=1)
label(0x2fba, "add_difficulty_level_loop")
decimal(0x2fc1)
comment(0x2fc6, "remember diamonds required", indent=1)
label(0x2fc6, "got_offset_to_per_stage_data")
comment(0x2fcb, "show diamonds required on status bar", indent=1)
comment(0x2fd0, "remember time remaining", indent=1)
comment(0x2fd5, "show time remaining on status bar", indent=1)
comment(0x2fda, "return zero", indent=1)
unused(0x2fdd)

expr(0x301b, "sprite_0")
ret(0x302b)
unused(0x302c)
expr(0x3047, make_lo("pause_message"))
expr(0x3056, make_lo("pause_message"))
expr(0x305e, make_lo("players_and_men_status_bar"))
expr(0x3077, make_lo("out_of_time_message"))
expr(0x30cc, make_lo("status_bar_sprite_numbers"))
ret(0x30dc)
unused(0x30ec)

label(0x3100, "demonstration_keys")
byte(0x3100, 0x60)
label(0x3160, "demonstration_key_durations")
entry(0x31c0, "entry_point")
expr(0x31cc, make_hi("status_bar_sprite_numbers"))
comment(0x31d3, "increment to point to credits text at $3300", indent=1)
expr(0x31d7, make_lo("status_bar_sprite_numbers"))
label(0x31da, "show_credits_loop")
unused(0x31e7)

label(0x3200, "tile_map")
blank(0x3200)
label(0x3200, "status_bar_sprite_numbers")
label(0x3201, "required_diamonds_on_status_bar")
label(0x3203, "total_diamonds_on_status_bar_high_digit")
label(0x3204, "total_diamonds_on_status_bar_low_digit")
label(0x320e, "score_on_status_bar")
label(0x3211, "hundreds_digit_of_score_on_status_bar")
blank(0x3214)
label(0x3214, "players_and_men_status_bar")
label(0x321b, "player_number_on_status_bar")
label(0x321e, "men_number_on_status_bar")
label(0x3225, "cave_letter_on_status_bar")
string(0x3225, 1)
label(0x3227, "difficulty_level_on_status_bar")
blank(0x3228)
blank(0x323c)
expr(0x324d, "'B'")
blank(0x3250)
label(0x3250, "highscore_high_status_bar")
blank(0x3264)
label(0x3264, "bonus_life_text")
string(0x3264, 1)
string(0x3266, 1)
string(0x3268, 1)
string(0x326a, 1)
string(0x326c, 1)
string(0x3271, 1)
string(0x3273, 1)
string(0x3275, 1)
string(0x3277, 1)
blank(0x3278)
label(0x3278, "number_of_players_status_bar")
label(0x3280, "plural_for_player")
label(0x3289, "cave_letter")
string(0x3289, 1)
label(0x328b, "number_of_players_status_bar_difficulty_level")
blank(0x328c)
label(0x328c, "game_over_text")
label(0x329e, "player_number_on_game_over_text")
label(0x32a0, "scrolling_pause_text")
label(0x32b4, "out_of_time_message")
string(0x32b4, 1)
string(0x32b6, 1)
string(0x32b8, 1)
string(0x32bb, 1)
string(0x32bd, 1)
string(0x32c1, 1)
string(0x32c3, 1)
string(0x32c5, 1)
string(0x32c7, 1)
string(0x32c8, 3)
label(0x32c8, "pause_message")
string(0x32d3, 2)
label(0x32dc, "highscore_last_status_bar")
label(0x32f0, "zeroed_status_bar")

blank(0x3300)
label(0x3300, "copy_of_credits")
comment(0x3300, """
Basic program for debugging purposes. Starts the game.
On startup, this is immediately overwritten by the credits text.

10*KEY 1 MO.4|M PAGE=13056 |M|N
20 MODE 5
30 VDU 23;8202;0;0;0;       (turns off the cursor)
40 *FX 178,0,0              (disables keyboard interrupts)
50 CALL 12736               (start the code at the regular entry_point)
60 *FX 178,255,0            (enables keyboard interrupts)
""")

blank(0x336c)
comment(0x336c, """
A fragment of the original source code (unused).

80 JSR 10829
90 JSR 8850:LDA #220:STA 105
100 LDA #123:LDY #0:JSR 9001
110 JSR 8850:LDA #80:STA 105
120 LDA #125:LDY #128:JSR 9001
130 JSR 8850:LDX

Note there are no hex literals, everything's decimal. Which is unusual.

Translating this to hex form, we see this is the code at &3a06
80 JSR &2A4D
90 JSR &2292:LDA #&DC:STA &69
100 LDA #&7B:LDY #0:JSR &2329
110 JSR &2292:LDA #&50:STA &69
120 LDA #&7D:LDY #&80:JSR &2329
130 JSR &2292:LDX
""")

unused(0x336c)
byte(0x336c, 2)

blank(0x3400)
label(0x3400, "big_rockford_sprite")
byte(0x3400, 6*256)

label(0x3a00, "show_menu")
comment(0x3a09, "show last score line", indent=1)
expr(0x3a0d, make_lo("highscore_last_status_bar"))
expr(0x3a11, make_hi("screen_addr_row_28"))
expr(0x3a13, make_lo("screen_addr_row_28"))
comment(0x3a17, "show highscore line", indent=1)
expr(0x3a1b, make_lo("highscore_high_status_bar"))
expr(0x3a1f, make_hi("screen_addr_row_30"))
expr(0x3a21, make_lo("screen_addr_row_30"))
comment(0x3a25, "store cave letter and difficulty level number")
label(0x3a2c, "handle_menu_loop")
expr(0x3a37, "'A'")
expr(0x3a3d, "sprite_0")
expr(0x3a3e, "sprite_0")
label(0x3a45, "waiting_for_demo_loop")
expr(0x3a46, make_lo("number_of_players_status_bar"))
expr(0x3a61, "opcode_inx")
blank(0x3a80)
comment(0x3a80, "demo mode", indent=1)
expr(0x3a83, "sprite_0")
label(0x3a84, "zero_score_on_status_bar_loop")
label(0x3a99, "move_left_to_change_cave")
expr(0x3a9a, "opcode_dex")
label(0x3a9e, "self_modify_move_left_or_right")
label(0x3ab7, "decrease_difficulty_level")
label(0x3abb, "dont_go_below_one")
label(0x3abe, "toggle_one_or_two_players")
expr(0x3aca, "'S'")
label(0x3ad1, "show_rockford_again_and_play_game")
ret(0x3ae1)
unused(0x3ae2)
label(0x3aa3, "store_new_difficulty_level_selected")
label(0x3aaf, "increase_difficulty_level")

label(0x3b00, "play_game")
expr(0x3b0f, "sprite_2")
expr(0x3b19, "sprite_0")
expr(0x3b33, "sprite_0")
comment(0x3b48, "add new difficulty level to menu", indent=1)
label(0x3b4b, "skip_adding_new_difficulty_level_to_menu")
expr(0x3b71, "sprite_0")
expr(0x3b91, "sprite_0")
expr(0x3b92, "sprite_0")
expr(0x3bc3, "'A'")
expr(0x3bc9, "sprite_0")
ret(0x3bcc)
unused(0x3bcd)

label(0x4700, "strip_data")
addr = 0x4700
for i in range(20):
    length = get_u8_binary(0x4c7c + i)
    label(addr, f"strip_data_for_cave_{i}")
    byte(addr, length)
    addr += length

unused(0x4af1)

blank(0x4b00)
label(0x4b00, "diamond_score_before_enough_obtained_for_each_cave")
stars(0x4b00)
label(0x4b14, "diamond_score_after_enough_obtained_for_each_cave")
blank(0x4b28)
label(0x4b28, "required_diamonds_for_each_cave_difficulty_level_1")
label(0x4b3c, "time_limit_for_each_cave_difficulty_level_1")
#byte(0x4b3c, 20)
blank(0x4b50)
label(0x4b50, "required_diamonds_for_each_cave_difficulty_level_2")
label(0x4b64, "time_limit_for_each_cave_difficulty_level_2")
#byte(0x4b64, 20)
blank(0x4b78)
label(0x4b78, "required_diamonds_for_each_cave_difficulty_level_3")
label(0x4b8c, "time_limit_for_each_cave_difficulty_level_3")
#byte(0x4b8c, 20)
blank(0x4ba0)
label(0x4ba0, "required_diamonds_for_each_cave_difficulty_level_4")
label(0x4bb4, "time_limit_for_each_cave_difficulty_level_4")
#byte(0x4bb4, 20)
blank(0x4bc8)
label(0x4bc8, "required_diamonds_for_each_cave_difficulty_level_5")
label(0x4bdc, "time_limit_for_each_cave_difficulty_level_5")
#byte(0x4bdc, 20)
blank(0x4bf0)
for i in range(240):
    decimal(0x4b00+i)
    if (i % 10) == 0:
        byte(0x4b00+i, 10)

label(0x4bf0, "start_y")
ten_by_two(0x4bf0)

label(0x4c04, "start_x")
ten_by_two(0x4c04)
label(0x4c18, "end_y")
ten_by_two(0x4c18)
label(0x4c2c, "end_x")
ten_by_two(0x4c2c)
label(0x4c40, "cave_play_order")
for i in range(20):
    decimal(0x4c40 + i)
    decimal(0x4c54 + i)
ten_by_two(0x4c40)
ten_by_two(0x4c54)
label(0x4c68, "number_of_difficuly_levels_available_in_menu_for_each_cave")
ten_by_two(0x4c68)
ten_by_two(0x4c7c, "length_of_strip_data_for_each_cave")
ten_by_two(0x4c90, "fill_cell_in_lower_nybble_strip_value_to_skip_in_upper_for_each_cave")
ten_by_two(0x4ca4, "colour_1_lower_nybble_block_type_1_upper_for_each_cave")
ten_by_two(0x4ca4+20*1, "colour_2_lower_nybble_block_type_2_upper_for_each_cave")
ten_by_two(0x4ca4+20*2, "colour_3_lower_nybble_block_type_3_upper_for_each_cave")
ten_by_two(0x4ca4+20*3, "cave_to_data_set")
stars(0x4cf4)
label(0x4cf4, "data_sets")

unused(0x4df8)
blank(0x4e09)
blank(0x4f41)
unused(0x4f41)

label(0x5028, "backwards_status_bar")
unused(0x503c)
label(0x5068, "default_status_bar")
string(0x5079, 1)
unused(0x507c)

label(0x5128, "unused_fragment_of_basic1")
byte(0x512c, 4)
label(0x5168, "unused_fragment_of_basic2")
byte(0x517b, 5)

for i in range(24):
    addr = 0x5000+i*64
    if i != 16 and i != 17 and i != 18 and i != 19:
        ten_by_four(addr, f"map_row_{i}")
        blank(addr+40)
        if i != 0 and i != 1 and i != 4 and i != 5:
            unused(addr+40)
    else:
        label(addr, f"map_row_{i}")

message(0x5400, 0x5500)

blank(0x5400)
label(0x5400, "credits")
label(0x2450, "jsr_handler_instruction")
label(0x2451, "handler_low")
label(0x2452, "handler_high")

comment(0x5568, "unused copy of routine at $5700")
entry(0x5568)
#unused(0x5568)
unused(0x557b)

blank(0x5600)
byte(0x5600, 0xb8)
label(0x5600, "tune_pitches_and_commands")
label(0x560e+200, "command_pitch")
label(0x561a+200, "command_note_repeat_counts")
acorn.sound(0x56b8, "sound1")
label(0x56bc, "sound1_pitch")
label(0x56be, "sound1_duration")
acorn.sound(0x56c0, "sound2")
acorn.sound(0x56c8, "sound3")
label(0x56d0, "tune_position_per_channel")
byte(0x56d0, 3)
label(0x56d3, "tune_note_repeat_per_channel")
byte(0x56d3, 3)
label(0x56dc, "command_note_durations")
label(0x56e8, "tune_start_position_per_channel")
byte(0x56e8, 3)
label(0x56ee, "tune_note_durations_table")
byte(0x56ee, 4)
decimal(0x56ee)
decimal(0x56ef)
decimal(0x56f0)
decimal(0x56f1)
byte(0x56f2, 14)
unused(0x56f2)

label(0x5700, "reset_tune")
label(0x5709, "reset_tune_loop")
label(0x5713, "update_tune")
label(0x5717, "update_channels_loop")
label(0x573b, "skip_end_of_tune_check")
decimal(0x573f)
expr(0x5749, "command_note_repeat_counts-200")
label(0x574e, "skip_reset_note_repeat")
expr(0x574f, "command_pitch-200")
expr(0x5753, "command_note_durations - 200")
label(0x575c, "note_found")
label(0x5777, "skip_increment_tune_position")
expr(0x5784, make_lo("sound1"))
expr(0x5787, make_hi("sound1"))
label(0x578d, "move_to_next_tune_channel")
unused(0x5796)

label(0x5bc0, "start_of_grid_screen_address")
label(0x5800, "big_rockford_destination_screen_address")
label(0x5800 + 6*0x140, "screen_addr_row_6")
label(0x5800 + 28*0x140, "screen_addr_row_28")
label(0x5800 + 30*0x140, "screen_addr_row_30")
acorn.bbc()

print(""";
; Disassembly of Boulderdash, by TobyLobster 2024
; This is a disassembly of the version from http://bbcmicro.co.uk/game.php?id=669
;
; File: ___1___
;
""")

go()
