# Disassembler

import sys
import logging
logger = logging.getLogger(__name__)
handler = logging.StreamHandler(stream=sys.stdout)
logger.addHandler(handler)

from commands import *
import acorn

config.set_label_references(False)
config.set_hex_dump(True)
#config.set_bytes_as_ascii(False)
config.set_show_autogenerated_labels(False)
config.set_show_cpu_state(False)
config.set_show_char_literals(False)
config.set_show_all_labels(False)

def sound(addr, lab):
    label(addr, lab)
    word(addr, 1)
    word(addr+2, 1)
    word(addr+4, 1)
    word(addr+6, 1)
    decimal(addr+2)
    decimal(addr+4)
    decimal(addr+6)
    comment(addr,   "channel   (2 bytes)", inline=True)
    comment(addr+2, "amplitude (2 bytes)", inline=True)
    comment(addr+4, "pitch     (2 bytes)", inline=True)
    comment(addr+6, "duration  (2 bytes)", inline=True)


def envelope(addr, lab):
    label(addr, lab)
    for i in range(addr, addr+14):
        byte(i, 1)
        decimal(i)
    comment(addr, "envelope number", inline=True)
    comment(addr+1, "step length (100ths of a second)", inline=True)
    comment(addr+2, "pitch change per step in section 1", inline=True)
    comment(addr+3, "pitch change per step in section 2", inline=True)
    comment(addr+4, "pitch change per step in section 3", inline=True)
    comment(addr+5, "number of steps in section 1", inline=True)
    comment(addr+6, "number of steps in section 2", inline=True)
    comment(addr+7, "number of steps in section 3", inline=True)
    comment(addr+8, "change of amplitude per step during attack phase", inline=True)
    comment(addr+9, "change of amplitude per step during decay phase", inline=True)
    comment(addr+10, "change of amplitude per step during sustain phase", inline=True)
    comment(addr+11, "change of amplitude per step during release phase", inline=True)
    comment(addr+12, "target of level at end of attack phase", inline=True)
    comment(addr+13, "target of level at end of decay phase", inline=True)

# NOTE:
#
#   Ranges here are *binary* NOT the *runtime* addresses as used everywhere else.
#   This is to make the addresses unique.
#
substitute_labels = {
    (0x260e, 0x2800): {
        "data_set_ptr_low": "sound_active_flag_table",
        "data_set_ptr_high": "sound1_active_flag",
    },
    (0x2c80, 0x2cec): {
        "data_set_ptr_low": "sound_active_flag_table",
    },
    (0x2300, 0x23db): {
        "cell_above_left": "grid_column_counter",
    },
    (0x2400, 0x2500): {
        "tile_map_ptr_low": "tile_y",
        "tile_map_ptr_high": "tile_x",
    },
    (0x2626, 0x2689): {
        "cell_above_left": "neighbouring_cell_variable",
    },
    (0x295c, 0x2973): {
        "sound2_active_flag": "remember_y",
    },
    (0x2a00, 0x2a28): {
        "real_keys_pressed": "x_loop_counter",
    },
    (0x2b00, 0x2b85): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
    },
    (0x2900, 0x2d45): {
        "loop_counter": "value_to_not_write_as_a_strip",
    },
    (0x2d00, 0x2d45): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
        "real_keys_pressed": "lower_nybble_value",
    },
    (0x28c0, 0x28d3): {
        "dissolve_to_solid_flag": "amount_to_increment_status_bar",
    },
    (0x2f82, 0x2fb8): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
    },
    (0x3a00, 0x3b00): {
        "l006a": "timeout_until_demo_mode",
    },
}

# Common helper routines
class SubstituteLabels():
    def __init__(self, substitute_labels):
        self.substitute_labels = substitute_labels

        # Create the substitute labels but with inverted dictionaries
        self.inverse_labels = {}
        for pair in self.substitute_labels:
            dict = self.substitute_labels[pair]
            inv_dict = {v: k for k, v in dict.items()}
            self.inverse_labels[pair] = inv_dict

            # HACK: also make labels lXXXX, which seems redundant, but changes the way the label_maker suggestions works
            for key in dict:
                m = re.match("l([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])", key)
                if m:
                    addr = int(m.group(1), 16)
                    label(addr, key)

    def substitute_label_maker(self, addr, context, suggestion):
        for pair in self.substitute_labels:
            if context in range(pair[0], pair[1]):
                dict = self.substitute_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        # stop using the substitution if not in range
        for pair in self.inverse_labels:
            if context not in range(pair[0], pair[1]):
                dict = self.inverse_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        return suggestion

def ab(addr, add_blank=False):
    comment(addr, "ALWAYS branch", inline=True)
    if add_blank:
        blank(addr+2)

def ri(addr, message=""):
    if message == "":
        message = "redundant instruction"
    comment(addr, message, inline=True)

return_count = 1

def ret(addr):
    global return_count
    label(addr, f"return{return_count}")
    return_count += 1

unused_count = 1

def unused(addr):
    global unused_count
    label(addr, f"unused{unused_count}")
    unused_count += 1

def unused_entry(addr):
    global unused_count
    entry(addr, f"unused{unused_count}")
    unused_count += 1

def stars(addr, message=""):
    c = "*************************************************************************************"
    if message == True:
        blank(addr)
    elif message != "":
        c = c + "\n\n" + message + "\n\n*************************************************************************************"
    comment(addr, c)

def ten_by_four(addr, lab = None):
    blank(addr)
    ten_by_two(addr, lab)
    byte(addr+20, 10)
    byte(addr+30, 10)

def ten_by_two(addr, lab = None):
    if lab:
        label(addr, lab)
    byte(addr, 10)
    byte(addr+10, 10)

def message(start_addr, end_addr):
    string_length = 0
    for i in range(start_addr, end_addr):
        b = get_u8_binary(i)
        if b >= ord('A') and b <= ord('Z'):
            if string_length == 0:
                string_start = i
            string_length += 1
        else:
            if string_length > 0:
                string(string_start, string_length)
                string_length = 0
            byte(i)
            if b in sprites:
                expr(i, sprites)
    if string_length > 0:
        string(string_start, string_length)
        string_length = 0

load(0x1300, "original/___1___", "6502")

label(0x0046, "sound0_active_flag")
label(0x0047, "sound1_active_flag")
label(0x0046, "data_set_ptr_low")
label(0x0047, "data_set_ptr_high")
label(0x0048, "sound2_active_flag")
label(0x0049, "sound3_active_flag")
label(0x004a, "sound4_active_flag")
label(0x004b, "sound5_active_flag")
label(0x004c, "sound6_active_flag")
label(0x004d, "sound7_active_flag")

label(0x004e, "pause_counter")
label(0x0050, "magic_wall_state")
label(0x0051, "magic_wall_timer")
label(0x0055, "fungus_growth_interval")
label(0x0057, "fungus_counter")
label(0x0058, "ticks_since_last_direction_key_pressed")
label(0x0059, "countdown_while_switching_palette")
label(0x005a, "tick_counter")
label(0x005b, "current_rockford_sprite")
label(0x005c, "sub_second_ticks")
label(0x005d, "previous_direction_keys")
label(0x005e, "just_pressed_direction_keys")
label(0x0062, "keys_to_process")
label(0x0064, "neighbour_cell_contents")
label(0x0065, "demo_mode_tick_count")
label(0x0067, "demo_key_duration")
label(0x0069, "status_text_address_low")
label(0x006a, "map_rockford_end_position_addr_low")
label(0x006b, "map_rockford_end_position_addr_high")
label(0x006c, "diamonds_required")
label(0x006d, "time_remaining")
label(0x006f, "bonus_life_available")
label(0x0070, "map_rockford_current_position_addr_low")
label(0x0071, "map_rockford_current_position_addr_high")
label(0x0072, "dissolve_to_solid_flag")

cell_directions = {
    0x73: "cell_above_left",
    0x74: "cell_above",
    0x75: "cell_above_right",
    0x76: "cell_left",
    0x77: "cell_current",
    0x78: "cell_right",
    0x79: "cell_below_left",
    0x7a: "cell_below",
    0x7b: "cell_below_right",
}

for c in cell_directions:
    label(c, cell_directions[c])

label(0x007c, "real_keys_pressed")
label(0x0073, "grid_x")
label(0x0077, "loop_counter")
label(0x0079, "initial_cell_fill_value")
label(0x007e, "visible_top_left_map_x")
label(0x007f, "visible_top_left_map_y")
label(0x0080, "screen_addr2_low")
label(0x0081, "screen_addr2_high")
label(0x0082, "next_ptr_low")
label(0x0083, "next_ptr_high")
label(0x0084, "wait_delay_centiseconds")

label(0x0085, "tile_map_ptr_low")
label(0x0086, "tile_map_ptr_high")

label(0x0087, "cave_number")
label(0x0088, "random_seed")
label(0x0089, "difficulty_level")
label(0x008a, "screen_addr1_low")
label(0x008b, "screen_addr1_high")
label(0x008c, "ptr_low")
label(0x008d, "ptr_high")
label(0x008e, "sound_channel")
label(0x008f, "offset_to_sound")

# (Class SubstituteLabels is defined in common.py to implement the substitute labels)
s = SubstituteLabels(substitute_labels)
set_label_maker_hook(s.substitute_label_maker)

comment(0x1300, """*************************************************************************************
Caves: There are 20 caves total (16 main caves A-P plus four bonus caves Q-T)
Difficulty levels: 1-5 for each cave

Some definitions:
* A *stage* consists of a cave letter and difficulty level. e.g. A1 is a stage.
* The *tile map* is the 40x23 map of the entire stage.
  Rows are separated by 64 bytes in memory, despite only being 40 bytes in length.
  (This is to simplify the conversion between row number and address and vice-versa).
  Other data is placed in between some of the rows.
* The *grid* is the visible area of sprites, showing a 20x12 section of the tile map.
  An offscreen cache of the sprites currently displayed in the grid is stored in the 'grid_of_currently_displayed_sprites' array.
  Using this we only need to draw the sprites that have changed since the previous tick.
* The *status bar* is single row of text at the top of the grid, showing the current score etc.
  Each player has a status bar, and different status bars are shown while the game is paused.

Cell values in tile_map:

$00 = empty space
$01 = earth
$02 = wall
$03 = titanium wall      (as seen on the border of the whole map)
$04 = diamond
$05 = rock
$06 = firefly            (with animation states $06, $16, $26, $36)
$07 = fungus             (states $07, $17, $27, $37, $47, $57, $67, and $77 as the fungus grows)
$08 = animated player appearing
$09 = 4x4 earth square with firefly pacing inside (or butterfly on cave D)
$0a = animated player exploding
$0b = vertical strip     (during preprocessing: value above is filled down to the next $0b)
$0c = horizontal strip   (during preprocessing: value is copied to the end of the row)
$0d = magic wall
$0e = butterfly          (with animation states $0e, $1e, $2e, $3e)
$0f = player             ($0f=waiting, $1f=walking left, $2f=walking right)

$18 = flashing exit
$21 = intro explosion frame #1
$11 = intro explosion frame #2
$43 = explosion out effect #1
$33 = explosion out effect #2
$23 = explosion out effect #3
$13 = explosion out effect #4

*************************************************************************************""")

sprites = {
    0: "sprite_space",
    1: "sprite_boulder1",
    2: "sprite_boulder2",
    3: "sprite_diamond1",
    4: "sprite_diamond2",
    5: "sprite_diamond3",
    6: "sprite_diamond4",
    7: "sprite_titanium_wall1",
    8: "sprite_titanium_wall2",
    9: "sprite_box",

    10: "sprite_wall1",
    11: "sprite_wall2",
    12: "sprite_explosion1",
    13: "sprite_explosion2",
    14: "sprite_explosion3",
    15: "sprite_explosion4",
    16: "sprite_magic_wall1",
    17: "sprite_magic_wall2",
    18: "sprite_magic_wall3",
    19: "sprite_magic_wall4",

    20: "sprite_fungus1",
    21: "sprite_fungus2",
    22: "sprite_butterfly1",
    23: "sprite_butterfly2",
    24: "sprite_butterfly3",
    25: "sprite_firefly1",
    26: "sprite_firefly2",
    27: "sprite_firefly3",
    28: "sprite_firefly4",
    29: "sprite_earth1",

    30: "sprite_earth2",
    31: "sprite_pathway",
    32: "sprite_rockford_blinking1",
    33: "sprite_rockford_blinking2",
    34: "sprite_rockford_blinking3",
    35: "sprite_rockford_winking1",
    36: "sprite_rockford_winking2",
    37: "sprite_rockford_moving_down1",
    38: "sprite_rockford_moving_down2",
    39: "sprite_rockford_moving_down3",

    40: "sprite_rockford_moving_up1",
    41: "sprite_rockford_moving_up2",
    42: "sprite_rockford_moving_left1",
    43: "sprite_rockford_moving_left2",
    44: "sprite_rockford_moving_left3",
    45: "sprite_rockford_moving_left4",
    46: "sprite_rockford_moving_right1",
    47: "sprite_rockford_moving_right2",
    48: "sprite_rockford_moving_right3",
    49: "sprite_rockford_moving_right4",

    50: "sprite_0",
    51: "sprite_1",
    52: "sprite_2",
    53: "sprite_3",
    54: "sprite_4",
    55: "sprite_5",
    56: "sprite_6",
    57: "sprite_7",
    58: "sprite_8",
    59: "sprite_9",

    60: "sprite_white",
    61: "sprite_dash",
    62: "sprite_slash",
    63: "sprite_comma",
    64: "sprite_full_stop",
}

sprite_addr = {
    0: "sprite_addr_space",
    1: "sprite_addr_boulder1",
    2: "sprite_addr_boulder2",
    3: "sprite_addr_diamond1",
    4: "sprite_addr_diamond2",
    5: "sprite_addr_diamond3",
    6: "sprite_addr_diamond4",
    7: "sprite_addr_titanium_wall1",
    8: "sprite_addr_titanium_wall2",
    9: "sprite_addr_box",

    10: "sprite_addr_wall1",
    11: "sprite_addr_wall2",
    12: "sprite_addr_explosion1",
    13: "sprite_addr_explosion2",
    14: "sprite_addr_explosion3",
    15: "sprite_addr_explosion4",
    16: "sprite_addr_magic_wall1",
    17: "sprite_addr_magic_wall2",
    18: "sprite_addr_magic_wall3",
    19: "sprite_addr_magic_wall4",

    20: "sprite_addr_fungus1",
    21: "sprite_addr_fungus2",
    22: "sprite_addr_butterfly1",
    23: "sprite_addr_butterfly2",
    24: "sprite_addr_butterfly3",
    25: "sprite_addr_firefly1",
    26: "sprite_addr_firefly2",
    27: "sprite_addr_firefly3",
    28: "sprite_addr_firefly4",
    29: "sprite_addr_earth1",

    30: "sprite_addr_earth2",
    31: "sprite_addr_pathway",
    32: "sprite_addr_rockford_blinking1",
    33: "sprite_addr_rockford_blinking2",
    34: "sprite_addr_rockford_blinking3",
    35: "sprite_addr_rockford_winking1",
    36: "sprite_addr_rockford_winking2",
    37: "sprite_addr_rockford_moving_down1",
    38: "sprite_addr_rockford_moving_down2",
    39: "sprite_addr_rockford_moving_down3",

    40: "sprite_addr_rockford_moving_up1",
    41: "sprite_addr_rockford_moving_up2",
    42: "sprite_addr_rockford_moving_left1",
    43: "sprite_addr_rockford_moving_left2",
    44: "sprite_addr_rockford_moving_left3",
    45: "sprite_addr_rockford_moving_left4",
    46: "sprite_addr_rockford_moving_right1",
    47: "sprite_addr_rockford_moving_right2",
    48: "sprite_addr_rockford_moving_right3",
    49: "sprite_addr_rockford_moving_right4",

    50: "sprite_addr_0",
    51: "sprite_addr_1",
    52: "sprite_addr_2",
    53: "sprite_addr_3",
    54: "sprite_addr_4",
    55: "sprite_addr_5",
    56: "sprite_addr_6",
    57: "sprite_addr_7",
    58: "sprite_addr_8",
    59: "sprite_addr_9",

    60: "sprite_addr_white",
    61: "sprite_addr_dash",
    62: "sprite_addr_slash",
    63: "sprite_addr_comma",
    64: "sprite_addr_full_stop",
    65: "sprite_addr_A",
    66: "sprite_addr_B",
    67: "sprite_addr_C",
    68: "sprite_addr_D",
    69: "sprite_addr_E",

    70: "sprite_addr_F",
    71: "sprite_addr_G",
    72: "sprite_addr_H",
    73: "sprite_addr_I",
    74: "sprite_addr_J",
    75: "sprite_addr_K",
    76: "sprite_addr_L",
    77: "sprite_addr_M",
    78: "sprite_addr_N",
    79: "sprite_addr_O",

    80: "sprite_addr_P",
    81: "sprite_addr_Q",
    82: "sprite_addr_R",
    83: "sprite_addr_S",
    84: "sprite_addr_T",
    85: "sprite_addr_U",
    86: "sprite_addr_V",
    87: "sprite_addr_W",
    88: "sprite_addr_X",
    89: "sprite_addr_Y",

    90: "sprite_addr_Z",

    96: "sprite_addr_titanium_wall1",
}

for i in sprites:
    constant(i, sprites[i])

ranges = [(0x1ee0, 0x1ef0),
          (0x1ef3, 0x1efa),
          (0x1efb, 0x1f00),
          (0x1f32, 0x1f37),
          (0x1f38, 0x1f46),
          (0x1f4c, 0x1f52),
          (0x1f55, 0x1f56),
          (0x1f57, 0x1f5a),
          (0x3200, 0x3214),
          (0x321a, 0x3220),
          (0x3223, 0x3225),
          (0x3226, 0x323c),
          (0x3242, 0x3248),
          (0x324b, 0x324d),
          (0x324e, 0x3258),
          (0x325c, 0x3264),
          (0x3265, 0x3266),
          (0x3267, 0x3268),
          (0x3269, 0x326a),
          (0x326b, 0x326c),
          (0x326d, 0x3271),
          (0x3272, 0x3273),
          (0x3274, 0x3275),
          (0x3276, 0x3277),
          (0x3278, 0x327a),
          (0x3280, 0x3284),
          (0x328a, 0x328d),
          (0x3291, 0x3292),
          (0x3296, 0x3297),
          (0x329d, 0x32a1),
          (0x32ae, 0x32af),
          (0x32b3, 0x32b4),
          (0x32b5, 0x32b6),
          (0x32b7, 0x32b8),
          (0x32b9, 0x32bb),
          (0x32bc, 0x32bd),
          (0x32be, 0x32c1),
          (0x32c2, 0x32c3),
          (0x32c4, 0x32c5),
          (0x32c6, 0x32c7),
          (0x32cb, 0x32cc),
          (0x32d1, 0x32d3),
          (0x32d5, 0x32d6),
          (0x32dc, 0x32e4),
          (0x32e8, 0x3300),
          (0x5028, 0x502a),
          (0x5030, 0x5034),
          (0x503a, 0x503c),
          (0x506e, 0x5074),
          (0x5077, 0x5079),
          (0x507a, 0x507c),
          ]

constant(0x0, "map_space")
constant(0x1, "map_earth")
constant(0x2, "map_wall")
constant(0x3, "map_titanium_wall")
constant(0x4, "map_diamond")
constant(0x5, "map_rock")
constant(0x6, "map_firefly")
constant(0x7, "map_fungus")
constant(0x8, "map_rockford_appearing")
constant(0x9, "map_earth_plus_firefly_4x4")
constant(0xa, "map_explosion")
constant(0xb, "map_vertical_strip")
constant(0xc, "map_horizontal_strip")
constant(0xd, "map_magic_wall")
constant(0xe, "map_butterfly")
constant(0xf, "map_player")     # second type?
constant(0x00, "map_anim_state0")
constant(0x10, "map_anim_state1")
constant(0x20, "map_anim_state2")
constant(0x30, "map_anim_state3")
constant(0x80, "map_unprocessed")

blank(0x1e80)
stars(0x1e80)
label(0x1e80, "idle_animation_data")    # put this before the "sprite_addr_" labels so it takes precedence.

for r in ranges:
    for i in range(r[0], r[1]):
        byte(i)
        expr(i, sprites)

for i in range(16):
    decimal(0x1e60+i)
    byte(0x1e60+i)

addrs = [0] * 106
for i in range(0, 97):
    addr = get_u8_binary(0x2000+i) + 256*get_u8_binary(0x2080+i)
    if i in sprite_addr:
        name  = sprite_addr[i]
        if addr not in addrs:
            addrs[i] = addr
    else:
        name  = "unused_sprite_addr_" + str(i)
    label(addr, name)
    byte(0x2000+i)
    byte(0x2080+i)
    expr(0x2000+i, make_lo(name))
    expr(0x2080+i, make_hi(name))

for i in range(64):
    byte(0x1e80+i)

unused(0x2061)
byte(0x2061, 0x2080-0x2061)
unused(0x20e1)
byte(0x20e1, 0x2100-0x20e1)

i = 1
while i < len(addrs):
    length = addrs[i] - addrs[i-1]
    utils.warn(i)
    if length > 0:
        byte(addrs[i-1], length)
    i=i+1
for i in range(0x2228, 0x2228+8):
    inkey_key = get_u8_binary(i)
    constant(inkey_key, acorn.inkey_enum[inkey_key])
    expr(i, acorn.inkey_enum)
    byte(i)

data_sets_present = []
for addr in range(0x4ce0, 0x4cf4):
    if get_u8_binary(addr) < 128:
        data_sets_present.append(get_u8_binary(addr))

basics = {}
patches = []
j = 0
for data_set in range(len(data_sets_present)):
    addr = 0x4cf4 + data_set * 20
    label(addr, "data_set_"+ str(j))
    j += 1

    for difficulty in range(5):
        byte(addr, 4)
        basics_addr = 0x4e00 + get_u8_binary(addr)
        map_start = get_u8_binary(addr + 1)
        if map_start >= 128:
            basics_addr += 0x100
            map_start = map_start & 127
        map_start += 0x5000
        patch_addr = get_u8_binary(addr + 2) + 256*get_u8_binary(addr + 3)
        patch_label = ""
        if patch_addr != 0:
            patch_label = f"patch_for_data_set_{data_set}_difficulty_{difficulty+1}"
            label(patch_addr, patch_label)
            patch_label = "="+patch_label
        comment(addr, f"Difficulty {difficulty+1}: basics={hex(basics_addr)}, map_start={hex(map_start)}, patch_addr={hex(patch_addr)}{patch_label}", inline=True)
        addr += 4
        if not basics_addr in basics:
            basics[basics_addr] = f"basics_for_data_set_{j}_difficulty_{difficulty+1}"
            label(basics_addr, basics[basics_addr])
        if patch_addr != 0:
            if patch_addr not in patches:
                patches.append(patch_addr)

patches.sort()
prev = patches[0]
for i in range(1, len(patches)):
    length = 0
    for j in range(256):
        length += 1
        v = get_u8_binary(prev + j)
        if (v & 7) == 3:
            break
    byte(prev, length)
    prev = patches[i]

byte(0x46bc, 0x46e8-0x46bc)
unused(0x3de4)
unused(0x42e8)
unused(0x46e8)
blank(0x46e8)

constant(20, "total_caves")
constant(0xac, "opcode_ldy_abs")
constant(0xb9, "opcode_lda_abs_y")
constant(0xca, "opcode_dex")
constant(0xe8, "opcode_inx")

label(0x0c00, "grid_of_currently_displayed_sprites")

label(0x1300, "initial_clock_value")

stars(0x1e60, True)
label(0x1e70, "set_clock_value")
byte(0x1e70,5)
unused(0x1e75)
for i in range(64):
    v = get_u8_binary(0x1e80+i)
    t = v // 16
    b = v & 15
    t += 32
    b += 32
    expr(0x1e80+i, f"16*({sprites[t]}-0x20) + {sprites[b]}-0x20")
label(0x1e60, "initial_values_of_variables_from_0x50")
expr(0x2e21, "initial_values_of_variables_from_0x50")
comment(0x1e80, "Sprites to use for idle animation of rockford. They are encoded into the nybbles of each byte. First it cycles through the bottom nybbles until near the end of the idle animation, then cycles through through the top nybbles")
stars(0x1ec0, True)
unused(0x1ee0)
blank(0x1ee0)

label(0x1f00, "sprite_to_next_sprite")

for i in range(15):
    v = get_u8_binary(0x1f00+i)
    if v in sprites:
        expr(0x1f00+i, sprites)
    byte(0x1f00+i)

stars(0x1f00, True)
blank(0x1f0f)
unused(0x1f0f)
byte(0x1f0f, 35)
blank(0x1f32)
string(0x1f56, 1)
blank(0x1f5a)
byte(0x1f5a, 38)
label(0x1f80, "cell_type_to_sprite")
message(0x1f80, 0x2000)
label(0x1f87, "fungus_animated_sprites1a")
label(0x1f8f, "rockford_sprite")
label(0x1f87+16, "fungus_animated_sprites1b")
label(0x1f87+16*2, "fungus_animated_sprites1c")
label(0x1f87+16*3, "fungus_animated_sprites1d")
label(0x1fc7, "fungus_animated_sprites2a")
label(0x1fc7+16, "fungus_animated_sprites2b")
label(0x1fc7+16*2, "fungus_animated_sprites2c")
label(0x1fc7+16*3, "fungus_animated_sprites2d")
for i in range(0x1f80, 0x2000, 16):
    blank(i)
    stars(i)

stars(0x2000, True)
label(0x2000, "sprite_addresses_low")
label(0x2007, "sprite_titanium_addressA")
label(0x2060, "sprite_titanium_addressB")
stars(0x2080, True)
label(0x2080, "sprite_addresses_high")

stars(0x2100, True)
blank(0x2120)
byte(0x2120, 16, 1)
label(0x2120, "items_produced_by_the_magic_wall")
expr(0x2124, make_add("map_unprocessed", "map_rock"))
expr(0x2125, make_add("map_unprocessed", "map_diamond"))
blank(0x2130)
label(0x2130, "some_array_of_cells")
blank(0x2140)
label(0x2140, "another_array_of_cells")
blank(0x2150)
label(0x2150, "index_to_cell_type")
label(0x2156, "exit_cell_type")
byte(0x2156, 9)
blank(0x215f)
unused(0x215f)
blank(0x2180)
byte(0x2180, 16)
blank(0x2190)
unused(0x2190)
stars(0x21c0, True)
byte(0x21c0, 16)
label(0x21c0, "handler_table_low")
byte(0x21d0, 16)
label(0x21d0, "handler_table_high")
stars(0x21e0, True)
label(0x21e0, "basic_replacements")
for i in range(16):
    byte(0x21e0+i)
expr(0x21e0, make_or("map_player","map_unprocessed"))
expr(0x21e1, make_or("map_player","map_unprocessed"))
expr(0x21e2, make_or("map_diamond","map_unprocessed"))
expr(0x21e3, "map_space")

# Before handlers
blank(0x259e)

handlers = { 0x22a5: "handler_basics",
             0x2500: "handler_firefly_or_butterfly",
             0x259e: "handler_fungus",
             0x2bca: "handler_firefly_in_box",
             0x26e3: "handler_rockford_intro_or_exit",
             0x23e0: "handler_for_vertical_strip",
             0x23f0: "handler_for_horizontal_strip",
             0x26ae: "handler_magic_wall",
             0x2600: "handler_rockford" }

for addr in handlers:
    stars(addr)
    label(addr, handlers[addr])

for i in range(16):
    addr1 = 0x21c0+i
    addr2 = 0x21d0+i
    addr = get_u8_binary(addr1) + 256*get_u8_binary(addr2)
    if addr != 0:
        entry(addr)
        if addr in handlers:
            expr(addr1, make_lo(handlers[addr]))
            expr(addr2, make_hi(handlers[addr]))

label(0x2200, "neighbouring_cell_variable_from_direction_index")
byte(0x2200)
expr(0x2200, "cell_right")
byte(0x2201)
expr(0x2201, "cell_left")
byte(0x2202)
expr(0x2202, "cell_above")
byte(0x2203)
expr(0x2203, "cell_below")
label(0x2204, "direction_offsets")
byte(0x2208, 20, 10)
label(0x221c, "firefly_cell_values")
for i in range(8):
    expr(0x221c+i, cell_directions)
    byte(0x221c+i)
label(0x2224, "rockford_cell_value_for_direction")
label(0x2228, "inkey_keys_table")
unused(0x2230)
entry(0x2230)
stars(0x2238)
label(0x2238, "increment_ptr_and_clear_carry")
label(0x223e, "skip_increment")
stars(0x2240)
label(0x2240, "add_a_to_ptr")
ret(0x2249)
stars(0x224a)
label(0x224a, "get_next_random_byte")
comment(0x224a, "a small 'pseudo-random' number routine. Generates a sequence of 256 numbers.")
stars(0x2256)
comment(0x2256, "Clears the entire map to initial_cell_fill_value.\nClears the visible grid to $ff")
label(0x2256, "clear_map_and_grid")
expr(0x2257, make_lo("tile_map_row_1-1"))
expr(0x225b, make_hi("tile_map_row_1-1"))
comment(0x2260, "initial random seed", indent=1)
decimal(0x2261)
label(0x2264, "clear_map_loop")
label(0x2276, "increment_ptr_using_40_bytes_out_of_every_64")
label(0x2292, "reset_grid_of_sprites")
label(0x2296, "reset_grid_of_sprites_loop")
comment(0x229c, "clear the current status bar", indent=1)
label(0x229e, "clear_status_bar_loop")
entry(0x22a5)
comment(0x22ad, "cell is in the range $90-$9f, so we look up the replacement in a table", indent=1)
label(0x22b1, "not_in_range_so_change_nothing")
stars(0x22b3)
label(0x22b3, "reveal_or_hide_more_cells")
expr(0x22b4, make_lo("tile_map_row_0"))
expr(0x22b8, make_hi("tile_map_row_0"))
comment(0x22bb, "loop over all the rows, X is the loop counter", indent=1)
decimal(0x22bc)
comment(0x22bf, "rows are stored in the first 40 bytes of every 64 bytes, so skip if we have exceeded the right range", indent=1)
decimal(0x22c0)
decimal(0x22c2)
comment(0x22c5, "progress a counter in a non-obvious pattern", indent=1)
comment(0x22c8, "if it's early in the process (tick counter is low), then branch more often so we reveal/hide the cells in a non-obvious pattern over time", indent=1)
comment(0x22d1, "clear the top bit to reveal the cell...", indent=1)
comment(0x22d3, "...or set the top bit to hide the cell", indent=1)
label(0x22d7, "skip_reveal_or_hide")
comment(0x22dc, "move forward to next row. Each row is stored at 64 byte intervals. We have moved on 40 so far so add the remainder to get to the next row", indent=1)
expr(0x22dd, "64-40")
label(0x22bd, "loop_over_rows")
label(0x22dc, "skip_to_next_row")
comment(0x22e4, "create some 'random' audio pitches to play while revealing/hiding the map. First multiply the data set pointer low byte by five and add one", indent=1)
comment(0x22ed, "add the cave number", indent=1)
comment(0x22ef, "just take some of the bits", indent=1)
comment(0x22f1, "use as the pitch", indent=1)
unused(0x22f9)
entry(0x22f9)
comment(0x22fb, "sta $2c16", indent=1)
nonentry(0x22fb)
entry(0x22fe)
unused(0x22ff)
entry(0x22ff)

stars(0x2300)
comment(0x2300, "draw a full grid of sprites, updating the current map position first")
label(0x2300, "draw_grid_of_sprites")
expr(0x2307, make_hi("screen_addr_row_6"))
expr(0x230b, make_lo("screen_addr_row_6"))
expr(0x230d, "opcode_lda_abs_y")
expr(0x2312, make_lo("grid_of_currently_displayed_sprites"))
expr(0x231a, make_hi("grid_of_currently_displayed_sprites"))
comment(0x2321, "X = number of cells to draw: 12 rows of 20 cells each (a loop counter)", indent=1)
expr(0x2322, "20*12")
ab(0x2323, True)
stars(0x2325)
label(0x2325, "draw_status_bar")
expr(0x2326, make_lo("start_of_grid_screen_address"))
expr(0x2328, make_hi("start_of_grid_screen_address"))
label(0x2329, "draw_single_row_of_sprites")
expr(0x232c, make_hi("current_status_bar_sprites"))
expr(0x232e, make_lo("current_status_bar_sprites"))
label(0x233b, "instruction_for_self_modification")
label(0x233c, "status_text_address_high")
expr(0x233c, make_hi("regular_status_bar"))
expr(0x2340, "opcode_ldy_abs")
comment(0x2344, "X is the cell counter (20 for a single row)", indent=1)
decimal(0x2345)
label(0x234a, "draw_grid")
label(0x234c, "draw_grid_loop")
label(0x2350, "grid_draw_row_loop")
comment(0x2355, "Y=9 indicates the titanium wall (while revealing the grid)", indent=1)
comment(0x2357, "this next instruction is either:\n    'ldy cell_type_to_sprite' [which in this context is equivalent to a no-op] OR \n    'lda cell_type_to_sprite,y'\nas set by self-modifying code above", indent=1)
label(0x2357, "load_instruction")
label(0x235b, "compare_instruction")
label(0x235c, "grid_compare_address_low")
label(0x235d, "grid_compare_address_high")
label(0x2360, "write_instruction")
label(0x2361, "grid_write_address_low")
label(0x2362, "grid_write_address_high")
comment(0x2375, "Each sprite is two character rows tall. screen_addr2_low/high is the destination screen address for the second character row of the sprite", indent=1)
comment(0x2381, "This next loop draws a single sprite in the grid.\nIt draws two character rows at the same time, with 16 bytes in each row.", indent=1)
label(0x2383, "draw_sprite_loop")
label(0x23a9, "skip_draw_sprite")
comment(0x23a9, "move the screen pointer on 16 pixels to next column", indent=1)
label(0x23b4, "skip_high_byte2")
decimal(0x23b9)
comment(0x23bc, "return if we have drawn all the rows (X=0)", indent=1)
comment(0x23bf, "move screen pointer on to next row of sprites (two character rows)", indent=1)
comment(0x23cc, "move tile pointer on to next row (64 bytes)", indent=1)

ret(0x23db)
unused(0x23dc)
comment(0x23e0, "Handler for filling in a vertical strip. Set the cells between two $0b's (including the $0b's themselves) to the value above the first $0b.")
expr(0x23e1, "map_vertical_strip")
label(0x23e8, "replace_cell_below")
comment(0x23ea, "copy cell above to current cell, clearing top bit", indent=1)
comment(0x23f0, "Handler for a horizontal strip. Copy the left cell to the current and right cells, until the end of the row.")
label(0x23f9, "store_cell_right")
unused(0x23fe)
expr(0x242a, "map_diamond")

stars(0x2400, "This is the map processing that happens every tick during gameplay. The map is parsed to handle any changes required.")
label(0x2400, "update_map")
comment(0x2400, "set branch offset (self modifying code)", indent=1)
expr(0x2401, "update_map_space - branch_instruction - 2")
ab(0x2402, True)
stars(0x2404, "This is the preprocessing step prior to gameplay. The tile map is scanned looking for special cell values to replace e.g. with vertical strips or a firefly in a 4x4 box of earth. This step happens twice before gameplay. Once without processing horizontal strips, then once with. This means horizontal strips are applied last.")
label(0x2404, "preprocess_map")
comment(0x2404, "set branch offset (self modifying code)", indent=1)
expr(0x2405, "mark_cell_above_as_processed_and_move_to_next_cell - branch_instruction - 2")
label(0x2406, "set_branch_offset")
comment(0x2409, "twenty rows", indent=1)
decimal(0x240a)
expr(0x240e, make_hi("tile_map_row_0"))
expr(0x2412, make_lo("tile_map_row_0"))
comment(0x2415, "Each row is stored in the first 40 bytes of every 64 bytes. Here we set Y to start on the second row, after the titanium wall border", indent=1)
comment(0x2417, "loop through the twenty rows of map", indent=1)
label(0x2417, "tile_map_y_loop")
comment(0x2417, "38 columns (cells per row)", inline=1)
decimal(0x2418)
comment(0x241f, "move to the next cell", indent=1)
comment(0x2420, "read current cell contents into X", indent=1)
label(0x2423, "tile_map_x_loop")
comment(0x2423, "loop through the 38 cells in a row of map", indent=1)
comment(0x2423, "read next cell contents into cell_right", indent=1)
comment(0x242d, "if current cell is already processed (top bit set), then skip to next cell", indent=1)
comment(0x2430, "mark current cell as processed (set top bit)", indent=1)
comment(0x2433, "the lower four bits are the type, each of which has a handler to process it", indent=1)
comment(0x2439, "if we have an empty cell, branch (destination was set depending on where we entered this routine)", indent=1)
label(0x2439, "branch_instruction")
label(0x243a, "branch_offset")
comment(0x2444, "read cells into cell_above and cell_below variables", indent=1)
comment(0x2450, "call the handler for the cell based on the type (0-15)", indent=1)
comment(0x2453, "the handler may have changed the surreounding cells. store the new cell below", indent=1)
comment(0x2459, "store the new cell above", indent=1)
ab(0x245f, True)
stars(0x2461, "This is part of the preprocessing step prior to gameplay, when we find a space in the map")
label(0x2461, "mark_cell_above_as_processed_and_move_to_next_cell")
label(0x2467, "move_to_next_cell")
comment(0x2469, "store the new cell left back into the map", indent=1)
comment(0x246f, "update cell_left with the current cell value (in X)", indent=1)
comment(0x2471, "update the current cell value x from the cell_right variable", indent=1)
comment(0x2473, "move ptr to next position", indent=1)
comment(0x2475, "loop back for the rest of the cells in the row", indent=1)
comment(0x2479, "store the final previous_cell for the row", indent=1)
comment(0x247d, "move ptr to the start of the next row. Stride is 64, 38 entries done, so remainder to add is 64-38=26", indent=1)
decimal(0x247e)
comment(0x2482, "loop back for the rest of the rows", indent=1)
comment(0x2486, "clear top bit in final row", indent=1)
decimal(0x2487)
label(0x2488, "clear_top_bit_on_final_row_loop")
comment(0x2493, "clear top bit on end position", indent=1)
stars(0x249a, "This is the update when we find a space in the map during gameplay")
label(0x249a, "update_map_space")
comment(0x249a, "get cell below", indent=1)
comment(0x24a0, "check current cell", indent=1)
label(0x24a7, "not_c0_or_above")
label(0x24d0, "set_to_space")
ab(0x24d2, True)
label(0x24d4, "space_below_is_also_a_space")
comment(0x24d4, "set bit six of the cell below to indicate cell above is also a space")
ab(0x24d9, True)
label(0x24db, "process_c0_or_above")
comment(0x24dc, "look up table based on type", indent=1)
comment(0x24e4, "store in cell below", indent=1)
label(0x24e8, "dont_store_below")
expr(0x24ec, "sound5_active_flag")
comment(0x24ee, "store $4b or $4c in location $4b or $4c. Flashing animation?", indent=1)
comment(0x24f1, "mask off the top two bits for the current cell value", indent=1)
unused(0x24f7)

expr(0x2507, "cell_above_left-1")
ri(0x2509)
label(0x250b, "unnecessary_branch")
label(0x2542, "c0_or_above")
expr(0x2544, make_lo("another_array_of_cells"))
expr(0x254a, make_lo("some_array_of_cells"))
comment(0x2550, "read above left cell", indent=1)
comment(0x2556, "reset current cell to zero", indent=1)
comment(0x2558, "read above right cell", indent=1)
comment(0x255e, "read below left cell", indent=1)
comment(0x2564, "read below right cell", indent=1)
comment(0x256a, "loop 9 times", indent=1)
expr(0x256d, "cell_above_left-1")
expr(0x2577, "cell_above_left-1")
comment(0x257b, "write to above left cell", indent=1)
comment(0x2583, "write to above right cell", indent=1)
comment(0x2589, "write to below left cell", indent=1)
comment(0x258f, "write to below right cell", indent=1)
entry(0x2598)
unused(0x2598)
ret(0x25f5)
unused_entry(0x25f6)
unused_entry(0x25fc)

label(0x260e, "check_for_direction_key_pressed")
label(0x2626, "direction_key_pressed")
label(0x262b, "get_direction_index_loop")
comment(0x263b, "read cell contents from the given neighbouring cell variable y", indent=1)
comment(0x26f5, "ready to start playing", indent=1)
label(0x2667, "check_for_return_pressed")
comment(0x266d, "return (and direction) is pressed", indent=1)
comment(0x26e3, "mark rockford cell as visible", indent=1)
ab(0x2687, True)
stars(0x2689)
label(0x2689, "read_keys")
label(0x2691, "read_keys_loop")
unused(0x26ab)
comment(0x26b5, "read what's above the wall, getting the cell type from the lower nybble", indent=1)
comment(0x26ba, "read what cell types are allowed to fall through and what is produced as a result (rocks turn into diamonds and vice versa)", indent=1)
comment(0x26bf, "something will fall into the wall, clear the cell above", indent=1)
expr(0x26c0, make_add("map_unprocessed", "map_space"))
comment(0x26c7, "if the cell below isn't empty, then don't store the item below", indent=1)
label(0x26c3, "skip_storing_space_above")
comment(0x26cb, "store the item that has fallen through the wall below", indent=1)
label(0x26cd, "magic_wall_is_active")
comment(0x26d5, "magic wall becomes inactive once the timer has run out", indent=1)
label(0x26d7, "store_magic_wall_state")
label(0x26da, "check_if_magic_wall_is_active")
unused(0x26df)
comment(0x26e7, "branch if on exit", indent=1)
comment(0x26ef, "wait for flashing rockford animation to finish", indent=1)
expr(0x26fa, make_lo("regular_status_bar"))
ret(0x26fd)
unused(0x26fe)

stars(0x2700)
label(0x2700, "start_gameplay")
comment(0x2707, "Set A=0", indent=1)
comment(0x270c, "clear sound", indent=1)
label(0x270e, "zero_eight_bytes_loop")
comment(0x2713, "zero variables", indent=1)
comment(0x272c, "branch if not in demo mode", indent=1)
comment(0x2730, "if a key is pressed in demo mode, then return", indent=1)
label(0x2735, "update_demo_mode")
expr(0x2736, make_lo("regular_status_bar"))
comment(0x2737, "flip between status bar and demo mode text every 16 ticks", indent=1)
label(0x273f, "skip_demo_mode_text")
expr(0x273e, make_lo("demonstration_mode_text"))
blank(0x2752)
label(0x2752, "got_key")
comment(0x2755, "get the contents of the cell that rockford is influencing. This can be the cell underneath rockford, or by holding the RETURN key down and pressing a direction key it can be one of the neighbouring cells.\nWe clear the top bits to just extract the basic type.", indent=1)
expr(0x275c, "map_rockford_appearing")
label(0x2762, "rockford_is_not_appearing")
comment(0x276b, "check if the player is still alive by reading the current rockford sprite", indent=1)
comment(0x2773, "each 'second' of game time has 11 game ticks", indent=1)
decimal(0x2774)
comment(0x2777, "decrement time remaining", indent=1)
decimal(0x2778)
comment(0x2780, "out of time", indent=1)
expr(0x2781, make_lo("out_of_time_message"))
label(0x2787, "not_out_of_time")
comment(0x278d, "got earth. play sound 3", indent=1)
label(0x278f, "skip_earth")
comment(0x2793, "got diamond. play sounds", indent=1)
label(0x27a4, "skip_got_diamond")
comment(0x27a7, "update tick", indent=1)
comment(0x27a9, "update magic wall timer", indent=1)
decimal(0x27d8)
ret(0x27ef)
unused(0x27f0)
byte(0x27f0,16)

stars(0x2800)
label(0x2800, "update_grid_animations")
label(0x2804, "update_sprites_to_use_loop")
comment(0x280a, "look up the next sprite in the animation sequence", indent=1)
comment(0x2816, "use the tick counter (bottom two bits scaled up by 16) to update fungus animation", indent=1)
comment(0x282f, "animate exit", indent=1)
comment(0x2837, "update rockford idle animation", indent=1)
comment(0x2840, "check for nearing the end of the idle animation (range $c0-$ff).\nUse the top nybbles of the data if so.", indent=1)
comment(0x2844, "Near the end of the idle animation. Shift the upper nybble into the bottom nybble to get more idle sprites", indent=1)
label(0x2848, "extract_lower_nybble")
comment(0x284a, "set the rockford sprite", indent=1)
expr(0x284b, "sprite_rockford_blinking1")
unused(0x2852)
byte(0x2852, 14)
stars(0x2860)
label(0x2860, "read_keys_and_resolve_direction_keys")
comment(0x2863, "just get the direction keys (top nybble)", indent=1)
comment(0x2869, "look for any changes of direction. If so use the just pressed directions as input", indent=1)
comment(0x286d, "no new directions were pressed, so use the previous directions from last time.", indent=1)
label(0x2872, "direction_keys_changed")
comment(0x2876, "nothing was just pressed, so just use the currently pressed keys", indent=1)
label(0x2877, "store_active_direction_keys")
comment(0x287a, "remember the special (non-direction keys) only", indent=1)
comment(0x2880, "recall the active direction keys, and combine with the special keys", indent=1)
unused(0x288a)
label(0x2898, "increment_status_bar_number")
expr(0x28a3, "sprite_0")
stars(0x2898)
label(0x25a6, "update_fungus")
expr(0x28b1, "sprite_0")
label(0x28bc, "finished_change")
stars(0x28c0)
label(0x28c0, "add_a_to_status_bar_number_at_y")
label(0x28c8, "increment_number_loop")
label(0x28d1, "finished_add")
unused(0x28d4)
byte(0x28d4, 44)
label(0x28aa, "decrement_status_bar_number")

stars(0x2900)
label(0x2900, "prepare_stage")
comment(0x2910, "high nybbles in the cave colour arrays store the sprite to use for three basic block types. copy them into cell_above_left/cell_above/cell_above_right", indent=1)
label(0x2914, "loop_three_times")
expr(0x291c, "cell_above_left-1")
comment(0x291d, "add number of caves to Y, in order to get next block type", indent=1)
expr(0x2920, "total_caves")
comment(0x2922, "increment loop counter X", indent=1)
comment(0x2927, "look up which data set needed from the cave number", indent=1)
comment(0x292f, "start with ptr = data_sets", indent=1)
expr(0x2930, make_lo("data_sets"))
expr(0x2934, make_hi("data_sets"))
comment(0x2937, "Loop counter X is data set number.\nAdd X * twenty bytes to pointer to get to 'data_set_X' address", indent=1)
label(0x293a, "add_twenty_times_x_loop")
expr(0x293b, "total_caves")
label(0x2942, "got_data_set_X_address")
comment(0x2946, "set offset in Y = 4*(difficulty level-1)", indent=1)
comment(0x2951, "set next_ptr = $4e00+?ptr, and if top bit of (ptr?1) is set, increment high byte", indent=1)
comment(0x2959, "use the lower seven bits of (ptr?1) as ptr_low", indent=1)
comment(0x2964, "set ptr_low = (ptr?1) AND &7F", indent=1)
label(0x2964, "store_ptr_low_and_fill_with_basics")
comment(0x2969, "reset ptr to the start of the data_set_X", indent=1)
comment(0x2971, "recall Y and read the next two bytes as an address. Can be zero. For details?", indent=1)
label(0x2982, "add_strips")
expr(0x2983, make_lo("strip_data"))
expr(0x2987, make_hi("strip_data"))
comment(0x298a, "get value to skip when writing strips to the map", indent=1)
label(0x2995, "find_strip_data_for_cave_loop")
nonentry(0x299a)
nonentry(0x299c)
label(0x29a1, "found_strip_data_for_cave")
label(0x29ac, "set_palette")
label(0x29b0, "set_palette_loop")
stars(0x29c3)
unused_entry(0x29c3)
nonentry(0x29d2)
comment(0x29d2, "beq $299c", indent=1)
unused(0x29d4)
unused_entry(0x29d5)
unused(0x29db)
nonentry(0x29dd)
byte(0x29dd, 2)
comment(0x29dd, "bne $299a", indent=1)
entry(0x29df)
unused(0x29e0)

stars(0x2a00)
label(0x2a00, "increment_map_ptr")
label(0x2a17, "skip_increment_high_byte2")
ret(0x2a19)
stars(0x2a1a)
label(0x2a1a, "set_ptr_to_start_of_map")
expr(0x2a1b, make_lo("tile_map_row_1"))
label(0x2a1c, "set_ptr_high_to_start_of_map_with_offset_a")
label(0x2a1e, "set_ptr_high_to_start_of_map")
expr(0x2a1f, make_hi("tile_map_row_1"))
stars(0x2a29)
label(0x2a29, "palette_block")
byte(0x2a29)
label(0x2a2a, "palette_block+1")
byte(0x2a2a)
byte(0x2a2b)
byte(0x2a2c)
byte(0x2a2d)
stars(0x2a2e)
label(0x2a2e, "increment_next_ptr")
stars(0x2a35)
label(0x2a35, "set_palette_colour_ax")
stars(0x2a4d)
label(0x2a4d, "reset_clock")
label(0x2a56, "animate_flashing_spaces_and_check_for_bonus_life")
stars(0x2a56)
comment(0x2a56, "")
comment(0x2a56, """Animate the flashing spaces on the grid.\nCalculate and set palette colour 3 over a number of frames
Also checks for awarding a bonus life.

Sequence of colours to show.
countdown_while_changing_palette    physical colour to set
    7                                       7 (white)
    6                                       6 (cyan)
    5                                       5 (magenta)
    4                                       3 (yellow)
    3                                       7 (white)
    2                                       6 (cyan)
    1                                       5 (magenta)
    0                                       -
""")

comment(0x2a68, "set logical colour three", indent=1)
label(0x2a6a, "skip_setting_physical_colour_to_three")
comment(0x2a71, "restore to spaces", indent=1)
blank(0x2a79)
comment(0x2a79, "a bonus life is awarded every 500 points", indent=1)
label(0x2a79, "check_for_bonus_life")
expr(0x2a7d, "sprite_0")
expr(0x2a81, "sprite_5")
comment(0x2a84, "a bonus life only becomes available when the score doesn't have a zero or five in the hundreds column", indent=1)
label(0x2a89, "zero_or_five_in_hundreds_column")
label(0x2a8b, "check_for_non_zero_in_top_digits")
expr(0x2a8f, "sprite_0")
decimal(0x2a8a)
decimal(0x2a94)
comment(0x2a97, "all the top digits are zero, including the hundreds column, which means we are not 500 or more, so not eligible for a bonus life", indent=1)
label(0x2a9c, "non_zero_digit_found_in_hundreds_column_or_above")
comment(0x2ab0, "show bonus life text (very briefly)", indent=1)
expr(0x2ab1, make_lo("bonus_life_text"))
ret(0x2ab4)
label(0x2ab5, "draw_big_rockford")
stars(0x2ab5)
expr(0x2ab6, make_hi("big_rockford_destination_screen_address"))
expr(0x2aba, make_lo("big_rockford_destination_screen_address"))
expr(0x2abe, make_hi("big_rockford_sprite"))
label(0x2ac3, "draw_big_rockford_loop")
label(0x2aca, "check_if_byte_is_an_rle_byte_loop")
ab(0x2ad2, True)
stars(0x2ad4)
label(0x2ad4, "get_repeat_count")
label(0x2adc, "copy_x_bytes_in_rle_loop")
label(0x2ae6, "skip_inc_high")
ab(0x2ae9, True)
stars(0x2aeb)
label(0x2aeb, "get_next_ptr_byte")
ret(0x2af3)
unused(0x2af4)
blank(0x2af8)
label(0x2af8, "rle_bytes_table")
byte(0x2af8, 7)
blank(0x2aff)
unused(0x2aff)
comment(0x2aa0, "award bonus life", indent=1)
comment(0x2aa4, "set sprite for space to pathway", indent=1)
expr(0x2aa5, "sprite_pathway")
comment(0x2aa9, "start animating colour three", indent=1)
comment(0x2aad, "add one to the MEN count", indent=1)

stars(0x2b00)
label(0x2b00, "map_address_to_map_xy_position")
stars(0x2b15)
label(0x2b15, "map_xy_position_to_map_address")
stars(0x2b2c)
comment(0x2b2c, "Scrolls the map by setting the tile_map_ptr and visible_top_left_map_x and y")
label(0x2b2c, "update_map_scroll_position")
decimal(0x2b3d)
decimal(0x2b41)
label(0x2b45, "check_for_need_to_scroll_left")
label(0x2b4e, "check_for_need_to_scroll_down")
label(0x2b5e, "check_for_need_to_scroll_up")
label(0x2b67, "check_for_bonus_stages")
comment(0x2b6d, "bonus stage is always situated in top left corner", indent=1)
label(0x2b71, "skip_bonus_stage")
unused(0x2b85)
stars(0x2b90)
label(0x2b90, "wait_for_13_centiseconds_and_read_keys")
label(0x2b92, "wait_for_a_centiseconds_and_read_keys")
label(0x2b94, "wait_for_centiseconds_and_read_keys")
label(0x2b98, "wait_loop")
unused(0x2bc0)
comment(0x2bca, """store earth ('*') in the following locations around the current position, and clear the others:
00* 01* 02* 03*
40* 41  42  43*
80* 81  82  83*
C0* C1* C2* C3*""")
expr(0x2bcb, "map_earth")
label(0x2bdf, "loop_done")
ab(0x2bdd, True)
comment(0x2bd0, "this next loop runs four times from $c3 to $c0, then four times more from $03 to $00", indent=1)
label(0x2bd2, "store_earth_loop")
comment(0x2beb, "set A=0 to clear cells in the middle", indent=1)
comment(0x2bf3, "set firefly, or butterfly on cave D", indent=1)
expr(0x2bf4, "map_firefly")
comment(0x2bfb, "set butterfly", indent=1)
expr(0x2bfc, make_or("map_butterfly", "map_anim_state2"))
unused(0x2bfe)
ret(0x2bfd)

for i in range(0, 9):
    byte(0x2c00+i*4, 4)

stars(0x2c00, True)
comment(0x2c00, "Sound data packed into single bytes: channel, amplitude, pitch, duration")
comment(0x2c00, "Sound 0 = Fungus ambient sound")
comment(0x2c00, "Sound 1 = TODO")
comment(0x2c00, "Sound 2 = Movement sound")
comment(0x2c00, "Sound 3 = Got earth sound")
comment(0x2c00, "Sound 4 = Rock landing/Rockford appearing sound")
comment(0x2c00, "Sound 5 = TODO")
comment(0x2c00, "Sound 6 = Got all required diamonds / rockford exploding sound")
comment(0x2c00, "Sound 7 = TODO")
comment(0x2c00, "Sound 8 = TODO")
label(0x2c00, "in_game_sound_data")
label(0x2c24, "in_game_sound_block")
label(0x2c26, "in_game_sound_amplitude")
label(0x2c27, "in_game_sound_amplitude+1")
label(0x2c28, "in_game_sound_pitch")
label(0x2c2a, "in_game_sound_duration")
word(0x2c24)
word(0x2c26)
word(0x2c28)
word(0x2c2a)
stars(0x2c2c)
comment(0x2c2c, "If X is negative, then play sound (X AND 127) with pitch Y.\nIf X is non-negative, play sound X with default pitch.")
label(0x2c2c, "play_sound_x_pitch_y")
label(0x2c31, "skip_using_default_pitch1")
comment(0x2c38, "sound 6 also plays sound 7", indent=1)
label(0x2c3d, "play_raw_sound_x_pitch_y")
expr(0x2c4d, "in_game_sound_data+1")
label(0x2c59, "skip_negative_amplitude")
comment(0x2c5c, "use default pitch", indent=1)
expr(0x2c5d, "in_game_sound_data+2")
label(0x2c5f, "skip_using_default_pitch2")
expr(0x2c63, "in_game_sound_data+3")
unused(0x2c71)
stars(0x2c80)
label(0x2c80, "update_sounds")
comment(0x2c92, "play rising pitch as time up is approaching", indent=1)
label(0x2ca0, "skip_playing_countdown_sounds")
expr(0x2ca6, "in_game_sound_data+2")
label(0x2cb7, "skip_sound_0")
label(0x2ce8, "play_sound_if_needed")
ret(0x2cef)
unused(0x2cf0)

stars(0x2d00)
label(0x2d00, "write_strips")
label(0x2d0a, "write_next_strip_loop")
label(0x2d12, "skip_high_byte1")
comment(0x2d12, "remember value", indent=1)
comment(0x2d13, "get repeat count (from high nybble) into X", indent=1)
label(0x2daf, "skip_write")
comment(0x2d19, "recall value", indent=1)
label(0x2d1e, "write_strip_loop")
comment(0x2d20, "a value of 10 means move to the next row", indent=1)
comment(0x2d24, "if it's this cave's skip value, then don't write to the map", indent=1)
label(0x2d2a, "skip_write_to_map")
comment(0x2d2a, "move the map position one to the right, wrapping to the next row if needed", indent=1)
decimal(0x2d2f)
label(0x2d32, "move_to_next_row")
decimal(0x2d39)
label(0x2d3c, "get_map_address")
ab(0x2d42, True)
ret(0x2d44)
unused(0x2d45)
stars(0x2d50)
label(0x2d50, "add_patches")
expr(0x2d51, make_lo("tile_map_row_1-1"))
label(0x2d55, "add_patches_loop")
label(0x2d7a, "store_patch")
label(0x2d74, "patch_value_is_not_three_or_one")
label(0x2d7c, "next_patch")
comment(0x2d5a, "remember the byte read", indent=1)
comment(0x2d5b, "the top five bits are the offset into the map to change.", indent=1)
comment(0x2d60, "add X to ptr (where we only use 40 out of every 64 bytes for the map)", indent=1)
label(0x2d60, "add_X_to_map_ptr_loop")
comment(0x2d68, "recall the byte, and isolate the bottom three bits.", indent=1)
comment(0x2d6b, """0 = store value 0 (map_space)
1 = no change     (this is used to skip to offsets larger than 32 bytes.)
2 = store value 2 (map_wall)
3 = terminator
4 = store value 4 (map_diamond)
5 = store value 5 (map_rock)
6 = store value 6 (map_firefly)
7 = store value 1 (map_earth)""", indent=1)
label(0x2d7f, "pull_a_and_return")
unused(0x2d81)
stars(0x2d90)
label(0x2d90, "fill_with_basics")
comment(0x2d93, "read byte from stage. This is done 200 times (40x20 cells, 4 cells per byte)", indent=1)
label(0x2d93, "read_next_byte_loop")
comment(0x2d97, "increment to next byte", indent=1)
label(0x2d9d, "skip_increment_high_byte1")
comment(0x2da1, "Extract the top two bits of the stage byte. Each pair of bits holds a type to write into the cell. We shift down six times to get the index, and put the result in X.", indent=1)
label(0x2da1, "loop_for_each_byte")
comment(0x2da9, "if the index is zero, don't write to the map.", indent=1)
comment(0x2dab, "X=1,2 or 3. Look up the sprite to store in the cell (in the map).", indent=1)
expr(0x2dac, "cell_above_left-1")
comment(0x2db4, "recall the byte and shift twice to start reading the next pair of bits", indent=1)
ab(0x2dbb, True)
label(0x2dbd, "pull_and_return2")
unused_entry(0x2dbf)
unused(0x2dca)
comment(0x2dcf, "bpl $2da6\nbmi $2d98", indent=1)
nonentry(0x2dcf)
byte(0x2dcf, 2)
nonentry(0x2dd1)
ab(0x2dd1, True)
unused(0x2dd3)
nonentry(0x2dd3)
byte(0x2de9, 3)

stars(0x2e00)
label(0x2e00, "play_one_life")
expr(0x2e0b, make_lo("players_and_men_status_bar"))
comment(0x2e03, "a bonus life only becomes available when the score doesn't have a zero or five in the hundreds column", indent=1)
decimal(0x2e0f)
expr(0x2e13, make_lo("bonus_life_text"))
label(0x2e14, "skip_bonus_life_text")
comment(0x2e16, "check if we are in demo mode", indent=1)
expr(0x2e1b, make_lo("demonstration_mode_text"))
label(0x2e1e, "skip_setting_demo_mode_text")
comment(0x2e1e, "initialise variables $50-$5f", indent=1)
label(0x2e20, "initialise_variables_loop")
decimal(0x2e24)
label(0x2e29, "skip_setting_variable")
comment(0x2e2c, "don't process horizontal strips on the first preprocess pass", indent=1)
expr(0x2e2f, "handler_table_high+12")
comment(0x2e34, "now process horizontal strips on the second preprocess pass", indent=1)
expr(0x2e35, ">handler_for_horizontal_strip")
expr(0x2e37, "handler_table_high+12")
comment(0x2e3c, "map complete: draw titanium wall borders", indent=1)
comment(0x2e3f, "loop over all rows", indent=1)
decimal(0x2e40)
label(0x2e41, "write_left_and_right_borders_loop")
decimal(0x2e42)
comment(0x2e43, "write the right hand border", indent=1)
label(0x2e48, "hide_cells_loop")
comment(0x2e51, "write the left hand border", indent=1)
comment(0x2e5d, "write the top and bottom borders", indent=1)
decimal(0x2e60)
label(0x2e61, "write_top_and_bottom_borders_loop")
expr(0x2e80, "sprite_0")
expr(0x2e8a, make_lo("game_over_text"))
expr(0x2e8e, make_lo("highscore_high_status_bar"))
expr(0x2e97, make_lo("highscore_for_player_2"))
label(0x2e98, "got_pointer_to_score")
expr(0x2e93, "sprite_1")
label(0x2ea2, "compare_highscores_loop")
label(0x2ea9, "compare")
label(0x2eb0, "goto_next_digit")
ab(0x2eb5, True)
label(0x2eb7, "store_in_status_bar")
label(0x2eb8, "which_status_bar_address2_low")
blank(0x2ebd)
label(0x2ebd, "play_scren_dissolve_to_solid")
label(0x2ebf, "play_screen_dissolve_effect")
label(0x2ec9, "screen_dissolve_loop")
unused(0x2ee4)
byte(0x2ee4, 28)
label(0x2eaa, "which_status_bar_address1_low")

stars(0x2f00)
label(0x2f00, "got_diamond_so_update_status_bar")
expr(0x2f0a, "sprite_0")
expr(0x2f15, "sprite_0")
comment(0x2f2d, "open the exit", indent=1)
comment(0x2f33, "set total diamonds to zero", indent=1)
comment(0x2f3b, "show score per diamond on status bar", indent=1)
comment(0x2f45, "play sound 6", indent=1)
expr(0x2f34, "sprite_0")
ret(0x2f47)
unused(0x2f48)
stars(0x2f50)
label(0x2f50, "initialise_stage")
decimal(0x2f51)
label(0x2f59, "empty_status_bar_loop")
comment(0x2f64, "show initial diamond score amount on status bar", indent=1)
comment(0x2f6c, "show cave letter on status bar", indent=1)
comment(0x2f73, "show difficulty level on status bar", indent=1)
expr(0x2f77, "sprite_0")
comment(0x2f7b, "set the delay between fungus growth", indent=1)
comment(0x2f82, "put the end tile on the map", indent=1)
comment(0x2f9d, "put the start tile on the map", indent=1)
comment(0x2fb8, "add 40 to the cave number for each difficulty level above one", indent=1)
label(0x2fba, "add_difficulty_level_loop")
decimal(0x2fc1)
comment(0x2fc6, "remember diamonds required", indent=1)
label(0x2fc6, "got_offset_to_per_stage_data")
comment(0x2fcb, "show diamonds required on status bar", indent=1)
comment(0x2fd0, "remember time remaining", indent=1)
comment(0x2fd5, "show time remaining on status bar", indent=1)
comment(0x2fda, "return zero", indent=1)
unused(0x2fdd)

stars(0x3000)
expr(0x3005, "sound0_active_flag")
ab(0x300e, True)
decimal(0x301b)
comment(0x3028, "Set A=0", indent=1)
ret(0x302b)
unused(0x302c)
stars(0x3040)
label(0x3040, "check_for_pause_key")
comment(0x3046, "pause mode. show pause message.", indent=1)
comment(0x3057, "toggle between showing pause message and regular status bar every 16 ticks", indent=1)
label(0x305f, "skip_showing_players_and_men")
expr(0x3047, make_lo("pause_message"))
label(0x304e, "update_while_initially_pressing_pause_loop")
label(0x3053, "pause_loop")
expr(0x3056, make_lo("pause_message"))
expr(0x305e, make_lo("players_and_men_status_bar"))
label(0x03066, "update_while_finally_pressing_unpause_loop")
label(0x306c, "no_pause")
expr(0x3077, make_lo("out_of_time_message"))
expr(0x30cc, make_lo("regular_status_bar"))
ret(0x30dc)
stars(0x30dd)
label(0x30dd, "update_during_pause_mode")
comment(0x30e7, "check for pause key", indent=1)
unused(0x30ec)

stars(0x3100, True)
label(0x3100, "demonstration_keys")
byte(0x3100, 0x60)
label(0x3160, "demonstration_key_durations")
stars(0x31c0)
entry(0x31c0, "entry_point")
expr(0x31cc, make_hi("regular_status_bar"))
comment(0x31d3, "increment to point to credits text at $3300", indent=1)
expr(0x31d7, make_lo("regular_status_bar"))
label(0x31da, "show_credits_loop")
unused(0x31e7)

stars(0x3200, True)
label(0x3200, "regular_status_bar")
label(0x3201, "required_diamonds_on_status_bar")
label(0x3203, "total_diamonds_on_status_bar_high_digit")
label(0x3204, "total_diamonds_on_status_bar_low_digit")
label(0x320e, "score_on_regular_status_bar")
label(0x3211, "hundreds_digit_of_score_on_status_bar")
stars(0x3214, True)
label(0x3214, "players_and_men_status_bar")
label(0x321b, "player_number_on_regular_status_bar")
label(0x321e, "men_number_on_regular_status_bar")
label(0x3225, "cave_letter_on_regular_status_bar")
string(0x3225, 1)
label(0x3227, "difficulty_level_on_regular_status_bar")
stars(0x3228, True)
label(0x3228, "inactive_players_regular_status_bar")
label(0x3236, "score_on_inactive_players_regular_status_bar")
stars(0x323c, True)
label(0x323c, "inactive_players_and_men_status_bar")
label(0x3243, "player_number_on_inactive_players_and_men_status_bar")
label(0x3246, "number_of_men_on_inactive_players_and_men_status_bar")
label(0x324d, "cave_letter_on_inactive_players_and_men_status_bar")
label(0x324f, "difficulty_level_on_inactive_players_and_men_status_bar")
expr(0x324d, "'B'")
stars(0x3250, True)
label(0x3250, "highscore_high_status_bar")
label(0x325e, "highscore_for_player_2")
stars(0x3264, True)
label(0x3264, "bonus_life_text")
string(0x3264, 1)
string(0x3266, 1)
string(0x3268, 1)
string(0x326a, 1)
string(0x326c, 1)
string(0x3271, 1)
string(0x3273, 1)
string(0x3275, 1)
string(0x3277, 1)
stars(0x3278, True)
label(0x3278, "number_of_players_status_bar")
label(0x3280, "plural_for_player")
label(0x3289, "cave_letter")
string(0x3289, 1)
label(0x328b, "number_of_players_status_bar_difficulty_level")
stars(0x328c, True)
label(0x328c, "game_over_text")
label(0x329e, "player_number_on_game_over_text")
stars(0x32a0, True)
label(0x32a0, "demonstration_mode_text")
stars(0x32b4, True)
label(0x32b4, "out_of_time_message")
string(0x32b4, 1)
string(0x32b6, 1)
string(0x32b8, 1)
string(0x32bb, 1)
string(0x32bd, 1)
string(0x32c1, 1)
string(0x32c3, 1)
string(0x32c5, 1)
string(0x32c7, 1)
string(0x32c8, 3)
stars(0x32c8, True)
label(0x32c8, "pause_message")
string(0x32d3, 2)
stars(0x32dc, True)
label(0x32dc, "score_last_status_bar")
stars(0x32f0, True)
label(0x32f0, "zeroed_status_bar")

stars(0x3300, True)
label(0x3300, "copy_of_credits")
comment(0x3300, """
Basic program for debugging purposes. Starts the game.
On startup, this is immediately overwritten by the credits text.

10*KEY 1 MO.4|M PAGE=13056 |M|N
20 MODE 5
30 VDU 23;8202;0;0;0;       (turns off the cursor)
40 *FX 178,0,0              (disables keyboard interrupts)
50 CALL 12736               (start the code at the regular entry_point)
60 *FX 178,255,0            (enables keyboard interrupts)
""")

blank(0x336c)
comment(0x336c, """
A fragment of the original source code (unused).

80 JSR 10829
90 JSR 8850:LDA #220:STA 105
100 LDA #123:LDY #0:JSR 9001
110 JSR 8850:LDA #80:STA 105
120 LDA #125:LDY #128:JSR 9001
130 JSR 8850:LDX

Note there are no hex literals, everything's decimal. Which is unusual.

Translating this to hex form, we see this is the code at &3a06
80 JSR &2A4D
90 JSR &2292:LDA #&DC:STA &69
100 LDA #&7B:LDY #0:JSR &2329
110 JSR &2292:LDA #&50:STA &69
120 LDA #&7D:LDY #&80:JSR &2329
130 JSR &2292:LDX
""")

unused(0x336c)
byte(0x336c, 2)

stars(0x3400, True)
label(0x3400, "big_rockford_sprite")
byte(0x3400, 6*256)

stars(0x3a00)
label(0x3a00, "show_menu")
comment(0x3a09, "show last score line", indent=1)
expr(0x3a0d, make_lo("score_last_status_bar"))
expr(0x3a11, make_hi("screen_addr_row_28"))
expr(0x3a13, make_lo("screen_addr_row_28"))
comment(0x3a17, "show highscore line", indent=1)
expr(0x3a1b, make_lo("highscore_high_status_bar"))
expr(0x3a1f, make_hi("screen_addr_row_30"))
expr(0x3a21, make_lo("screen_addr_row_30"))
comment(0x3a28, "set cave letter and difficulty level number", indent=1)
label(0x3a2c, "handle_menu_loop")
expr(0x3a37, "'A'")
expr(0x3a3d, "sprite_0")
expr(0x3a3e, "sprite_0")
label(0x3a45, "waiting_for_demo_loop")
expr(0x3a46, make_lo("number_of_players_status_bar"))
expr(0x3a61, "opcode_inx")
blank(0x3a80)
comment(0x3a80, "demo mode", indent=1)
expr(0x3a83, "sprite_0")
label(0x3a84, "zero_score_on_status_bar_loop")
label(0x3a99, "menu_move_left_to_change_cave")
expr(0x3a9a, "opcode_dex")
label(0x3a9e, "self_modify_move_left_or_right")
label(0x3ab7, "decrease_difficulty_level")
label(0x3abb, "dont_go_below_one")
label(0x3abe, "toggle_one_or_two_players")
expr(0x3ac2, make_xor("sprite_1", "sprite_2"))
expr(0x3aca, "'S'")
label(0x3ad1, "show_rockford_again_and_play_game")
ret(0x3ae1)
unused(0x3ae2)
label(0x3aa3, "store_new_difficulty_level_selected")
label(0x3aaf, "increase_difficulty_level")

stars(0x3b00)
label(0x3b00, "initialise_and_play_game")
decimal(0x3b01)
label(0x3b02, "copy_status_bar_loop")
expr(0x3b0f, "sprite_2")
expr(0x3b19, "sprite_0")
label(0x3b1d, "set_cave_letter_on_status_bar")
comment(0x3b26, "copy difficuly level to other status bars", indent=1)
comment(0x3b32, "zero scores on status bars", indent=1)
expr(0x3b33, "sprite_0")
label(0x3b36, "zero_score_loop")
label(0x3b3f, "play_next_life")
comment(0x3b3f, "add current stage to menu availablility", indent=1)
comment(0x3b48, "add new difficulty level to menu", indent=1)
label(0x3b4b, "skip_adding_new_difficulty_level_to_menu")
comment(0x3b4e, "save results after life\nfirst find the position of the score to copy from the status bar (which depends on the player number)", indent=1)
comment(0x3b50, "check if player one or two", indent=1)
decimal(0x3b57)
comment(0x3b56, "copy score from player two", indent=1)
label(0x3b58, "copy_score")
label(0x3b5a, "copy_score_to_last_score_loop")
comment(0x3b70, "check for zero men left for the current player", indent=1)
comment(0x3b77, "check for zero men left for other player", indent=1)
expr(0x3b71, "sprite_0")
expr(0x3b91, "sprite_0")
expr(0x3b92, "sprite_0")
label(0x3bb3, "store_cave_number_and_difficulty_level")
comment(0x3bbb, "bonus life awarded on bonus level", indent=1)
expr(0x3bc3, "'A'")
expr(0x3bc9, "sprite_0")
ret(0x3bcc)
unused(0x3bcd)
#byte(0x3bcd, 0x4700 - 0x3bcd)
decimal(0x3b6d)
decimal(0x3b7d)
label(0x3b7c, "swap_status_bars_with_inactive_player_versions")
label(0x3b7e, "swap_loop")
label(0x3ba1, "calculate_next_cave_number_and_difficuly_level")
label(0x3bc1, "set_cave_number_and_difficulty_level_from_status_bar")

blank(0x3c00)
stars(0x3c00, """Patch data.

These patches are applied to the tile_map after the 'basics' (the basics being a two bit per cell base coat of paint for the stage).

The top five bits of each byte is the offset to the next patch byte (add one for an offset from 1 to 32 bytes), and the bottom three bits are what to do:

0 = store value 0 (map_space)
1 = no change     (this is used to skip to offsets larger than 32 bytes.)
2 = store value 2 (map_wall)
3 = terminator
4 = store value 4 (map_diamond)
5 = store value 5 (map_rock)
6 = store value 6 (map_firefly)
7 = store value 1 (map_earth)""")

blank(0x4700)
stars(0x4700)
label(0x4700, "strip_data")
addr = 0x4700
for i in range(20):
    length = get_u8_binary(0x4c7c + i)
    c = chr(ord('A') + i)
    label(addr, f"strip_data_for_cave_{c}")
    byte(addr, length)
    addr += length

unused(0x4af1)

blank(0x4b00)
label(0x4b00, "diamond_score_before_enough_obtained_for_each_cave")
stars(0x4b00)
label(0x4b14, "diamond_score_after_enough_obtained_for_each_cave")
blank(0x4b28)
label(0x4b28, "required_diamonds_for_each_cave_difficulty_level_1")
label(0x4b3c, "time_limit_for_each_cave_difficulty_level_1")
#byte(0x4b3c, 20)
blank(0x4b50)
label(0x4b50, "required_diamonds_for_each_cave_difficulty_level_2")
label(0x4b64, "time_limit_for_each_cave_difficulty_level_2")
#byte(0x4b64, 20)
blank(0x4b78)
label(0x4b78, "required_diamonds_for_each_cave_difficulty_level_3")
label(0x4b8c, "time_limit_for_each_cave_difficulty_level_3")
#byte(0x4b8c, 20)
blank(0x4ba0)
label(0x4ba0, "required_diamonds_for_each_cave_difficulty_level_4")
label(0x4bb4, "time_limit_for_each_cave_difficulty_level_4")
#byte(0x4bb4, 20)
blank(0x4bc8)
label(0x4bc8, "required_diamonds_for_each_cave_difficulty_level_5")
label(0x4bdc, "time_limit_for_each_cave_difficulty_level_5")
#byte(0x4bdc, 20)
blank(0x4bf0)
for i in range(240):
    decimal(0x4b00+i)
    if (i % 10) == 0:
        byte(0x4b00+i, 10)

label(0x4bf0, "start_y")
ten_by_two(0x4bf0)

label(0x4c04, "start_x")
ten_by_two(0x4c04)
label(0x4c18, "end_y")
ten_by_two(0x4c18)
label(0x4c2c, "end_x")
ten_by_two(0x4c2c)
label(0x4c40, "cave_play_order")
for i in range(20):
    decimal(0x4c40 + i)
    decimal(0x4c54 + i)
ten_by_two(0x4c40)
ten_by_two(0x4c54, "fungus_growth_intervals_for_cave")
label(0x4c68, "number_of_difficuly_levels_available_in_menu_for_each_cave")
ten_by_two(0x4c68)
ten_by_two(0x4c7c, "length_of_strip_data_for_each_cave")
ten_by_two(0x4c90, "fill_cell_in_lower_nybble_strip_value_to_skip_in_upper_for_each_cave")
ten_by_two(0x4ca4, "colour_1_lower_nybble_block_type_1_upper_for_each_cave")
ten_by_two(0x4ca4+20*1, "colour_2_lower_nybble_block_type_2_upper_for_each_cave")
ten_by_two(0x4ca4+20*2, "colour_3_lower_nybble_block_type_3_upper_for_each_cave")
ten_by_two(0x4ca4+20*3, "cave_to_data_set")
comment(0x4ce0, "each cave has a data set, except for the bonus levels")
decimal(0x4cec)
decimal(0x4cee)
decimal(0x4cef)
stars(0x4cf4, True)
label(0x4cf4, "data_sets")

unused(0x4df8)
blank(0x4df8)

stars(0x4e09, True)

blank(0x4f41)
unused(0x4f41)
byte(0x4f41, 0x5000-0x4f41)

label(0x5028, "current_status_bar_sprites")
unused(0x503c)
label(0x5068, "default_status_bar")
string(0x5079, 1)
unused(0x507c)

label(0x5128, "unused_fragment_of_basic1")
byte(0x512c, 4)
label(0x5168, "unused_fragment_of_basic2")
byte(0x517b, 5)

for i in range(24):
    addr = 0x5000+i*64
    if i != 16 and i != 17 and i != 18 and i != 19:
        ten_by_four(addr, f"tile_map_row_{i}")
        blank(addr+40)
        stars(addr)
        if i != 0 and i != 1 and i != 4 and i != 5:
            unused(addr+40)
    else:
        label(addr, f"tile_map_row_{i}")

message(0x5400, 0x5500)

stars(0x5400, True)
label(0x5400, "credits")
label(0x2450, "jsr_handler_instruction")
label(0x2451, "handler_low")
label(0x2452, "handler_high")

comment(0x5568, "unused copy of routine at $5700")
entry(0x5568)
unused(0x557b)

stars(0x5600, True)
byte(0x5600, 0xb8)
label(0x5600, "tune_pitches_and_commands")
label(0x560e+200, "command_pitch")
label(0x561a+200, "command_note_repeat_counts")
stars(0x56b8, True)
sound(0x56b8, "sound1")
label(0x56bc, "sound1_pitch")
label(0x56be, "sound1_duration")
blank(0x56c0)
sound(0x56c0, "sound2")
blank(0x56c8)
sound(0x56c8, "sound3")
blank(0x56d0)
label(0x56d0, "tune_position_per_channel")
byte(0x56d0, 3)
label(0x56d3, "tune_note_repeat_per_channel")
byte(0x56d3, 3)
label(0x56dc, "command_note_durations")
label(0x56e8, "tune_start_position_per_channel")
byte(0x56e8, 3)
label(0x56ee, "tune_note_durations_table")
byte(0x56ee, 4)
decimal(0x56ee)
decimal(0x56ef)
decimal(0x56f0)
decimal(0x56f1)
byte(0x56f2, 14)
blank(0x56f2)
unused(0x56f2)

stars(0x5700)
label(0x5700, "reset_tune")
label(0x5709, "reset_tune_loop")
stars(0x5713)
label(0x5713, "update_tune")
label(0x5717, "update_channels_loop")
label(0x573b, "skip_end_of_tune_check")
decimal(0x573f)
expr(0x5749, "command_note_repeat_counts-200")
label(0x574e, "skip_reset_note_repeat")
expr(0x574f, "command_pitch-200")
expr(0x5753, "command_note_durations - 200")
label(0x575c, "note_found")
label(0x5777, "skip_increment_tune_position")
expr(0x5784, make_lo("sound1"))
expr(0x5787, make_hi("sound1"))
label(0x578d, "move_to_next_tune_channel")
unused(0x5796)

label(0x5bc0, "start_of_grid_screen_address")
label(0x5800, "big_rockford_destination_screen_address")
label(0x5800 + 6*0x140, "screen_addr_row_6")
label(0x5800 + 28*0x140, "screen_addr_row_28")
label(0x5800 + 30*0x140, "screen_addr_row_30")
acorn.bbc()

print(""";
; Disassembly of Boulderdash, by TobyLobster 2024
; This is a disassembly of the BBC Micro version from http://bbcmicro.co.uk/game.php?id=669
;
; File: ___1___
;
""")

go()
