# Disassembler

import sys
import logging
logger = logging.getLogger(__name__)
handler = logging.StreamHandler(stream=sys.stdout)
logger.addHandler(handler)

from commands import *
import acorn

config.set_label_references(False)
config.set_hex_dump(True)
#config.set_bytes_as_ascii(False)
config.set_show_autogenerated_labels(False)
config.set_show_cpu_state(False)
config.set_show_char_literals(False)
config.set_show_all_labels(False)

# Common helper routines
class SubstituteLabels():
    def __init__(self, substitute_labels):
        self.substitute_labels = substitute_labels

        # Create the substitute labels but with inverted dictionaries
        self.inverse_labels = {}
        for pair in self.substitute_labels:
            dict = self.substitute_labels[pair]
            inv_dict = {v: k for k, v in dict.items()}
            self.inverse_labels[pair] = inv_dict

            # HACK: also make labels lXXXX, which seems redundant, but changes the way the label_maker suggestions works
            for key in dict:
                m = re.match("l([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])", key)
                if m:
                    addr = int(m.group(1), 16)
                    label(addr, key)

    def substitute_label_maker(self, addr, context, suggestion):
        for pair in self.substitute_labels:
            if context in range(pair[0], pair[1]):
                dict = self.substitute_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        # stop using the substitution if not in range
        for pair in self.inverse_labels:
            if context not in range(pair[0], pair[1]):
                dict = self.inverse_labels[pair]
                if suggestion[0] in dict:
                    return dict[suggestion[0]]

        return suggestion

def ab(addr, message=""):
    if message != "":
        message = ". "+message
    comment(addr, "ALWAYS branch" + message, inline=True)

def ri(addr, message=""):
    if message == "":
        message = "redundant instruction"
    comment(addr, message, inline=True)

unused_count = 1

def unused(addr):
    global unused_count
    label(addr, "unused"+str(unused_count))
    unused_count += 1

def unused_entry(addr):
    global unused_count
    entry(addr, "unused"+str(unused_count))
    unused_count += 1

def stars(addr, message=""):
    c = "*************************************************************************************"
    if message != "":
        c = c + "\n\n" + message + "\n\n*************************************************************************************"
    comment(addr, c)

def ten_by_four(addr, lab = None):
    blank(addr)
    ten_by_two(addr, lab)
    byte(addr+20, 10)
    byte(addr+30, 10)

def ten_by_two(addr, lab = None):
    if lab:
        label(addr, lab)
    byte(addr, 10)
    byte(addr+10, 10)

def message(start_addr, end_addr):
    string_length = 0
    for i in range(start_addr, end_addr):
        b = get_u8_binary(i)
        if b >= ord('A') and b <= ord('Z'):
            if string_length == 0:
                string_start = i
            string_length += 1
        else:
            if string_length > 0:
                string(string_start, string_length)
                string_length = 0
            byte(i)
            if b in sprites:
                expr(i, sprites)
    if string_length > 0:
        string(string_start, string_length)
        string_length = 0

load(0x1300, "original/___1___", "6502")

# NOTE:
#
#   Ranges here are *binary* NOT the *runtime* addresses as used everywhere else.
#   This is to make the addresses unique.
#
substitute_labels = {
    (0x2a00, 0x2a28): {
        "real_keys_pressed": "x_loop_counter",
    },
    (0x2b00, 0x2b85): {
        "ptr_low":  "map_address_low",
        "ptr_high": "map_address_high",
        "screen_addr1_low":  "map_x",
        "screen_addr1_high": "map_y",
    },
    (0x3a00, 0x3b00): {
        "l006a": "timeout_until_demo_mode",
    },
}

label(0x0046, "data_set_ptr_low")
label(0x0047, "data_set_ptr_high")
label(0x0059, "countdown_while_switching_palette")
label(0x005c, "sub_second_ticks")
label(0x005d, "previous_direction_keys")
label(0x005e, "just_pressed_direction_keys")
label(0x0062, "keys_to_process")
label(0x0065, "demo_mode_tick_count")
label(0x0067, "demo_key_duration")
label(0x0069, "status_text_address_low")
label(0x006c, "diamonds_required")
label(0x006f, "bonus_life_available")
label(0x0073, "sprite_for_block_type_1")
label(0x0074, "sprite_for_block_type_2")
label(0x0075, "sprite_for_block_type_3")
label(0x007c, "real_keys_pressed")
label(0x0073, "grid_x")
label(0x0077, "loop_counter")
label(0x0079, "initial_cell_fill_value")
label(0x007e, "visible_top_left_map_x")
label(0x007f, "visible_top_left_map_y")
label(0x0080, "screen_addr2_low")
label(0x0081, "screen_addr2_high")
label(0x0082, "next_ptr_low")
label(0x0083, "next_ptr_high")
label(0x0084, "wait_delay_centiseconds")

label(0x0085, "tile_map_ptr_low")
label(0x0086, "tile_map_ptr_high")

label(0x0087, "cave_number")
label(0x0088, "row_counter")
label(0x0089, "difficulty_level")
label(0x008a, "screen_addr1_low")
label(0x008b, "screen_addr1_high")
label(0x008c, "ptr_low")
label(0x008d, "ptr_high")
label(0x008e, "sound_channel")
label(0x008f, "offset_to_sound")

# (Class SubstituteLabels is defined in common.py to implement the substitute labels)
s = SubstituteLabels(substitute_labels)
set_label_maker_hook(s.substitute_label_maker)

comment(0x1300, """
Caves: A-P + Four bonus caves

tile_map:

$00 = empty
$01 = earth
$02 = wall
$03 = titanium wall
$04 = diamond
$05 = rock
$06 = exit
$07 = fungus
$08 = player
$09 = 4x4 earth square with monster pacing inside
$0a = animate explosion the player
$0b = Letter D/ Vertical column of earth?
$0c = Horizontal row of earth?
$0d = rock
$0e = butterfly
$0f = player
""")

sprites = {
    0: "sprite_space",
    1: "sprite_boulder1",
    2: "sprite_boulder2",
    3: "sprite_diamond1",
    4: "sprite_diamond2",
    5: "sprite_diamond3",
    6: "sprite_diamond4",
    7: "sprite_titanium_wall1",
    8: "sprite_titanium_wall2",
    9: "sprite_box",

    10: "sprite_wall1",
    11: "sprite_wall2",
    12: "sprite_explosion1",
    13: "sprite_explosion2",
    14: "sprite_explosion3",
    15: "sprite_explosion4",
    16: "sprite_magic_wall1",
    17: "sprite_magic_wall2",
    18: "sprite_magic_wall3",
    19: "sprite_magic_wall4",

    20: "sprite_fungus1",
    21: "sprite_fungus2",
    22: "sprite_butterfly1",
    23: "sprite_butterfly2",
    24: "sprite_butterfly3",
    25: "sprite_firefly1",
    26: "sprite_firefly2",
    27: "sprite_firefly3",
    28: "sprite_firefly4",
    29: "sprite_earth1",

    30: "sprite_earth2",
    31: "sprite_pathway",
    32: "sprite_rockford_blinking1",
    33: "sprite_rockford_blinking2",
    34: "sprite_rockford_blinking3",
    35: "sprite_rockford_winking1",
    36: "sprite_rockford_winking2",
    37: "sprite_rockford_moving_down1",
    38: "sprite_rockford_moving_down2",
    39: "sprite_rockford_moving_down3",

    40: "sprite_rockford_moving_up1",
    41: "sprite_rockford_moving_up2",
    42: "sprite_rockford_moving_left1",
    43: "sprite_rockford_moving_left2",
    44: "sprite_rockford_moving_left3",
    45: "sprite_rockford_moving_left4",
    46: "sprite_rockford_moving_right1",
    47: "sprite_rockford_moving_right2",
    48: "sprite_rockford_moving_right3",
    49: "sprite_rockford_moving_right4",

    50: "sprite_0",
    51: "sprite_1",
    52: "sprite_2",
    53: "sprite_3",
    54: "sprite_4",
    55: "sprite_5",
    56: "sprite_6",
    57: "sprite_7",
    58: "sprite_8",
    59: "sprite_9",

    60: "sprite_white",
    61: "sprite_dash",
    62: "sprite_slash",
    63: "sprite_comma",
    64: "sprite_full_stop",
}

sprite_addr = {
    0: "sprite_addr_space",
    1: "sprite_addr_boulder1",
    2: "sprite_addr_boulder2",
    3: "sprite_addr_diamond1",
    4: "sprite_addr_diamond2",
    5: "sprite_addr_diamond3",
    6: "sprite_addr_diamond4",
    7: "sprite_addr_titanium_wall1",
    8: "sprite_addr_titanium_wall2",
    9: "sprite_addr_box",

    10: "sprite_addr_wall1",
    11: "sprite_addr_wall2",
    12: "sprite_addr_explosion1",
    13: "sprite_addr_explosion2",
    14: "sprite_addr_explosion3",
    15: "sprite_addr_explosion4",
    16: "sprite_addr_magic_wall1",
    17: "sprite_addr_magic_wall2",
    18: "sprite_addr_magic_wall3",
    19: "sprite_addr_magic_wall4",

    20: "sprite_addr_fungus1",
    21: "sprite_addr_fungus2",
    22: "sprite_addr_butterfly1",
    23: "sprite_addr_butterfly2",
    24: "sprite_addr_butterfly3",
    25: "sprite_addr_firefly1",
    26: "sprite_addr_firefly2",
    27: "sprite_addr_firefly3",
    28: "sprite_addr_firefly4",
    29: "sprite_addr_earth1",

    30: "sprite_addr_earth2",
    31: "sprite_addr_pathway",
    32: "sprite_addr_rockford_blinking1",
    33: "sprite_addr_rockford_blinking2",
    34: "sprite_addr_rockford_blinking3",
    35: "sprite_addr_rockford_winking1",
    36: "sprite_addr_rockford_winking2",
    37: "sprite_addr_rockford_moving_down1",
    38: "sprite_addr_rockford_moving_down2",
    39: "sprite_addr_rockford_moving_down3",

    40: "sprite_addr_rockford_moving_up1",
    41: "sprite_addr_rockford_moving_up2",
    42: "sprite_addr_rockford_moving_left1",
    43: "sprite_addr_rockford_moving_left2",
    44: "sprite_addr_rockford_moving_left3",
    45: "sprite_addr_rockford_moving_left4",
    46: "sprite_addr_rockford_moving_right1",
    47: "sprite_addr_rockford_moving_right2",
    48: "sprite_addr_rockford_moving_right3",
    49: "sprite_addr_rockford_moving_right4",

    50: "sprite_addr_0",
    51: "sprite_addr_1",
    52: "sprite_addr_2",
    53: "sprite_addr_3",
    54: "sprite_addr_4",
    55: "sprite_addr_5",
    56: "sprite_addr_6",
    57: "sprite_addr_7",
    58: "sprite_addr_8",
    59: "sprite_addr_9",

    60: "sprite_addr_white",
    61: "sprite_addr_dash",
    62: "sprite_addr_slash",
    63: "sprite_addr_comma",
    64: "sprite_addr_full_stop",
    65: "sprite_addr_A",
    66: "sprite_addr_B",
    67: "sprite_addr_C",
    68: "sprite_addr_D",
    69: "sprite_addr_E",

    70: "sprite_addr_F",
    71: "sprite_addr_G",
    72: "sprite_addr_H",
    73: "sprite_addr_I",
    74: "sprite_addr_J",
    75: "sprite_addr_K",
    76: "sprite_addr_L",
    77: "sprite_addr_M",
    78: "sprite_addr_N",
    79: "sprite_addr_O",

    80: "sprite_addr_P",
    81: "sprite_addr_Q",
    82: "sprite_addr_R",
    83: "sprite_addr_S",
    84: "sprite_addr_T",
    85: "sprite_addr_U",
    86: "sprite_addr_V",
    87: "sprite_addr_W",
    88: "sprite_addr_X",
    89: "sprite_addr_Y",

    90: "sprite_addr_Z",

    96: "sprite_addr_titanium_wall1",
}

for i in sprites:
    constant(i, sprites[i])

ranges = [(0x1ee0, 0x1ef0),
          (0x1ef3, 0x1efa),
          (0x1efb, 0x1f00),
          (0x1f32, 0x1f37),
          (0x1f38, 0x1f46),
          (0x1f4c, 0x1f52),
          (0x1f55, 0x1f56),
          (0x1f57, 0x1f5a),
          (0x3200, 0x3214),
          (0x321a, 0x3220),
          (0x3223, 0x3225),
          (0x3226, 0x323c),
          (0x3242, 0x3248),
          (0x324b, 0x324d),
          (0x324e, 0x3258),
          (0x325c, 0x3264),
          (0x3265, 0x3266),
          (0x3267, 0x3268),
          (0x3269, 0x326a),
          (0x326b, 0x326c),
          (0x326d, 0x3271),
          (0x3272, 0x3273),
          (0x3274, 0x3275),
          (0x3276, 0x3277),
          (0x3278, 0x327a),
          (0x3280, 0x3284),
          (0x328a, 0x328d),
          (0x3291, 0x3292),
          (0x3296, 0x3297),
          (0x329d, 0x32a1),
          (0x32ae, 0x32af),
          (0x32b3, 0x32b4),
          (0x32b5, 0x32b6),
          (0x32b7, 0x32b8),
          (0x32b9, 0x32bb),
          (0x32bc, 0x32bd),
          (0x32be, 0x32c1),
          (0x32c2, 0x32c3),
          (0x32c4, 0x32c5),
          (0x32c6, 0x32c7),
          (0x32cb, 0x32cc),
          (0x32d1, 0x32d3),
          (0x32d5, 0x32d6),
          (0x32dc, 0x32e4),
          (0x32e8, 0x3300),
          (0x5028, 0x502a),
          (0x5030, 0x5034),
          (0x503a, 0x503c),
          (0x506e, 0x5074),
          (0x5077, 0x5079),
          (0x507a, 0x507c),
          ]

for r in ranges:
    for i in range(r[0], r[1]):
        byte(i)
        expr(i, sprites)

addrs = [0] * 106
for i in range(0, 105):
    if i in sprite_addr:
        name  = sprite_addr[i]
    else:
        name  = "sprite_addr_" + str(i)
    addr = get_u8_binary(0x2000+i) + 256*get_u8_binary(0x2080+i)
    if addr not in addrs:
        addrs[i] = addr
    label(addr, name)
    byte(0x2000+i)
    byte(0x2080+i)
    expr(0x2000+i, make_lo(name))
    expr(0x2080+i, make_hi(name))

#byte(0x2061, 0x2080-0x2061)
#byte(0x20df, 0x2100-0x20df)

unused(0x24f7)
i = 1
while i < len(addrs):
    length = addrs[i] - addrs[i-1]
    utils.warn(i)
    if length > 0:
        byte(addrs[i-1], length)
    i=i+1
for i in range(0x2228, 0x2228+8):
    inkey_key = get_u8_binary(i)
    constant(inkey_key, acorn.inkey_enum[inkey_key])
    expr(i, acorn.inkey_enum)
    byte(i)

j = 0
k = 0
for i in range(0, 130):
    addr = 0x4cf4 + 2*i
    level_addr = get_u8_binary(addr) + 256*get_u8_binary(addr + 1)

    byte(0x4cf4 + i)
    if (i % 10) == 0:
        label(0x4cf4 + 2*i, "data_set_"+ str(j))
        j += 1
        k = 0

    if level_addr != 0:
        #name = "data_" + str(j) + "_"+str(k)
        #label(level_addr, name)
        #expr(addr, name)
        k += 1

constant(20, "total_caves")
constant(0xac, "opcode_ldy_abs")
constant(0xb9, "opcode_lda_abs_y")
constant(0xca, "opcode_dex")
constant(0xe8, "opcode_inx")

label(0x0c00, "grid_of_screen_sprites")

label(0x1300, "initial_clock_value")

label(0x1e70, "set_clock_value")
unused(0x1ee0)
blank(0x1ee0)

byte(0x1f00, 15)
unused(0x1f0f)
byte(0x1f0f, 35)
blank(0x1f32)
string(0x1f56, 1)
blank(0x1f5a)
byte(0x1f5a, 38)
label(0x1f80, "cell_type_to_sprite")
byte(0x1f87, 8)
byte(0x1f87+8, 8)
byte(0x1f87+2*8, 8)
byte(0x1f87+3*8, 8)
byte(0x1f87+4*8, 8)
byte(0x1f87+5*8, 8)
byte(0x1f87+6*8, 8)
byte(0x1f87+7*8, 8)
byte(0x1f87+8*8, 8)
byte(0x1f87+9*8, 8)
byte(0x1f87+10*8, 8)
byte(0x1f87+11*8, 8)
byte(0x1f87+12*8, 8)
byte(0x1f87+13*8, 8)


label(0x2000, "sprite_addresses_low")
label(0x2007, "sprite_titanium_addressA")
label(0x2060, "sprite_titanium_addressB")
label(0x2080, "sprite_addresses_high")
unused(0x20df)

label(0x2150, "index_to_cell_type")
byte(0x2156, 9)

label(0x2228, "inkey_keys_table")
blank(0x2230)
unused(0x2230)
entry(0x2230)
label(0x2238, "increment_ptr_and_clear_carry")
label(0x223e, "skip_increment")
label(0x2240, "add_a_to_ptr")
label(0x2249, "return1")
label(0x224a, "reverse_nybbles_and_add_one")
comment(0x2256, "Clears the entire map to initial_cell_fill_value.\nClears the visible grid to $ff", indent=1)
label(0x2256, "clear_map_and_grid")
expr(0x2257, make_lo("map_row_0-1"))
expr(0x225b, make_hi("map_row_0-1"))
label(0x2276, "increment_ptr_using_40_bytes_out_of_every_64")
label(0x2292, "reset_grid_of_sprites")
label(0x2296, "reset_grid_of_sprites_loop")
label(0x229e, "clear_backwards_status_bar_loop")
unused(0x22a5)
entry(0x22a5)
unused(0x22b1)
expr(0x22b4, make_lo("special_cave_1"))
expr(0x22b8, make_hi("special_cave_1"))
unused(0x22f9)
entry(0x22f9)
unused(0x22ff)
entry(0x22ff)

label(0x2300, "draw_grid_of_sprites")
expr(0x2307, make_hi("screen_addr_row_6"))
expr(0x230b, make_lo("screen_addr_row_6"))
expr(0x230d, "opcode_lda_abs_y")
expr(0x2312, make_lo("grid_of_screen_sprites"))
expr(0x231a, make_hi("grid_of_screen_sprites"))
expr(0x2322, make_lo("zeroed_status_bar"))
ab(0x2323)
blank(0x2325)
label(0x2325, "draw_grid_at_regular_screen_address")
expr(0x2326, make_lo("start_of_grid_screen_address"))
expr(0x2328, make_hi("start_of_grid_screen_address"))
label(0x2329, "draw_grid")
expr(0x232c, make_hi("backwards_status_bar"))
expr(0x232e, make_lo("backwards_status_bar"))
label(0x233b, "instruction_for_self_modification")
label(0x233c, "status_text_address_high")
expr(0x233c, make_hi("tile_map"))
expr(0x2340, "opcode_ldy_abs")
expr(0x2345, make_lo("players_and_men_status_bar"))
label(0x234c, "draw_grid_loop")
label(0x2350, "grid_draw_row_loop")
label(0x2357, "opcode_to_change")
label(0x235c, "grid_addr1_low")
label(0x235d, "grid_addr1_high")
label(0x2361, "grid_addr2_low")
label(0x2362, "grid_addr2_high")
comment(0x2375, "Each sprite is two character rows tall. screen_addr2_low/high is the destination screen address for the second character row of the sprite", indent=1)
comment(0x2381, "This next loop draws a single sprite in the grid.\nIt draws two character rows at the same time, with 16 bytes in each row.", indent=1)
label(0x2383, "draw_sprite_loop")
label(0x23a9, "skip_draw_sprite")
decimal(0x23b9)
label(0x23db, "return2")
unused(0x23dc)
unused_entry(0x23e8)
unused_entry(0x23f0)
unused(0x23f0)
entry(0x23f9)
unused(0x23fe)

expr(0x240e, make_hi("special_cave_1"))
expr(0x2412, make_lo("special_cave_1"))

ri(0x2509)
entry(0x2598)
label(0x25f5, "return3")
unused_entry(0x25f6)
unused_entry(0x25fc)

unused_entry(0x2600)
unused(0x2609)
unused(0x260e)
unused(0x2616)
unused(0x2618)
unused(0x2626)
unused(0x262b)
unused(0x2636)
unused(0x2667)
unused(0x2674)
unused(0x2678)
blank(0x2689)
label(0x2689, "read_keys")
label(0x2691, "read_keys_loop")
unused_entry(0x26ad)
unused(0x26c3)
unused(0x26cd)
unused(0x26d7)
unused(0x26da)
entry(0x26df)
expr(0x26fa, make_lo("status_bar_sprite_numbers"))
unused(0x26fd)

label(0x2700, "start_gameplay")
label(0x2735, "update_demo_mode")
expr(0x273e, make_lo("scrolling_pause_text"))
comment(0x2777, "decrement time remaining", indent=1)
expr(0x2781, make_lo("out_of_time_message"))
label(0x27ef, "return4")
unused(0x27f0)
byte(0x27f0,16)

#label(0x2800, "update_rockford_animation")
unused(0x2852)
byte(0x2852, 14)
label(0x2860, "read_keys_and_resolve_direction_keys")
comment(0x2863, "just get the direction keys (top nybble)", indent=1)
comment(0x2869, "look for any changes of direction. If so use the just pressed directions as input", indent=1)
comment(0x286d, "no new directions were pressed, so use the previous directions from last time.", indent=1)
label(0x2872, "direction_keys_changed")
comment(0x2876, "nothing was just pressed, so just use the currently pressed keys", indent=1)
label(0x2877, "store_active_direction_keys")
comment(0x287a, "remember the special (non-direction keys) only", indent=1)
comment(0x2880, "recall the active direction keys, and combine with the special keys", indent=1)
unused(0x288a)
label(0x2898, "increment_status_bar_number")
expr(0x28a3, "sprite_0")
expr(0x28b1, "sprite_0")
label(0x28c0, "add_a_to_status_bar_number_at_y")
label(0x28aa, "decrement_status_bar_number")

label(0x2900, "prepare_level")
comment(0x2910, "high nybbles in the cave colour arrays store the sprite to use for three basic block types. copy them into sprite_for_block_type_1/2/3", indent=1)
label(0x2914, "loop_three_times")
expr(0x2920, "total_caves")
comment(0x2927, "look up the data set needed for the cave number", indent=1)
comment(0x292f, "start the pointer at data_sets", indent=1)
comment(0x2937, "Loop counter X is data set number.\nAdd X * twenty bytes to pointer to get to 'data_set_X' address", indent=1)
expr(0x2930, make_lo("data_sets"))
expr(0x2934, make_hi("data_sets"))
label(0x293a, "add_twenty_times_x_loop")
label(0x2942, "got_data_set_X_address")
comment(0x2946, "set offset in Y = 4*(difficulty level-1)", indent=1)
expr(0x293b, "total_caves")
comment(0x2951, "set next_ptr = $4e00+?ptr, and if top bit of (ptr?1) is set, increment high byte", indent=1)
comment(0x2964, "set ptr_low = (ptr?1) AND &7F", indent=1)
comment(0x2969, "reset ptr to the start of the data_set_X", indent=1)
expr(0x2983, make_lo("special_cave_0"))
expr(0x2987, make_hi("special_cave_0"))
nonentry(0x299a)
nonentry(0x299c)
label(0x29ac, "set_palette")
label(0x29b0, "set_palette_loop")
unused_entry(0x29c3)
label(0x29d4, "return5")
unused_entry(0x29d5)
nonentry(0x29dd)
byte(0x29dd, 2)
comment(0x29dd, "bne $299a", indent=1)
unused(0x29e0)
nonentry(0x29d2)
comment(0x29d2, "beq $299c", indent=1)
entry(0x29df)

label(0x2a00, "increment_map_ptr")
label(0x2a17, "skip_increment_high_byte2")
label(0x2a19, "return6")
label(0x2a1a, "set_ptr_to_start_of_map")
label(0x2a1c, "set_ptr_high_to_start_of_map_with_offset_a")
label(0x2a1e, "set_ptr_high_to_start_of_map")
expr(0x2a1b, make_lo("map_row_0"))
expr(0x2a1f, make_hi("map_row_0"))
label(0x2a29, "palette_block")
label(0x2a2a, "palette_block+1")
byte(0x2a29)
byte(0x2a2a)
byte(0x2a2b)
byte(0x2a2c)
byte(0x2a2d)
label(0x2a35, "set_palette_colour_ax")
label(0x2a4d, "reset_clock")
label(0x2a56, "animate_flashing_spaces_and_check_for_bonus_life")
stars(0x2a56)
comment(0x2a56, "")
comment(0x2a56, """Animate the flashing spaces on the grid.\nCalculate and set palette colour 3 over a number of frames
Also checks for awarding a bonus life.

Sequence of colours to show.
countdown_while_changing_palette    physical colour to set
    7                                       7 (white)
    6                                       6 (cyan)
    5                                       5 (magenta)
    4                                       3 (yellow)
    3                                       7 (white)
    2                                       6 (cyan)
    1                                       5 (magenta)
    0                                       -
""")

label(0x2a6a, "skip_setting_physical_colour_to_three")
comment(0x2a68, "set logical colour three", indent=1)
comment(0x2a71, "restore to spaces", indent=1)
blank(0x2a79)
comment(0x2a79, "a bonus life is awarded every 500 points", indent=1)
label(0x2a79, "check_for_bonus_life")
expr(0x2a7d, "sprite_0")
expr(0x2a81, "sprite_5")
label(0x2a89, "zero_or_five_in_hundreds_column")
label(0x2a8b, "check_for_non_zero_in_top_digits")
expr(0x2a8f, "sprite_0")
label(0x2a9c, "non_zero_digit_found_in_hundreds_column_or_above")
comment(0x2aa0, "award bonus life", indent=1)
comment(0x2aa4, "set sprite for space to pathway", indent=1)
comment(0x2aa9, "start animating colour three", indent=1)
comment(0x2aad, "add one to the MEN count", indent=1)
comment(0x2ab0, "show bonus life text (very briefly)", indent=1)
expr(0x2aa5, "sprite_pathway")
label(0x2ab5, "draw_big_rockford")
label(0x2ac3, "draw_big_rockford_loop")
stars(0x2ab5)
expr(0x2ab6, make_hi("big_rockford_destination_screen_address"))
expr(0x2aba, make_lo("big_rockford_destination_screen_address"))
label(0x2ab4, "return7")
expr(0x2abe, make_hi("big_rockford_sprite"))
label(0x2aca, "check_if_byte_is_an_rle_byte_loop")
label(0x2ad4, "get_repeat_count")
label(0x2ae6, "skip_inc_high")
label(0x2adc, "copy_x_bytes_in_rle_loop")
blank(0x2af8)
label(0x2af8, "rle_bytes_table")
label(0x2aeb, "get_next_ptr_byte")
label(0x2af3, "return8")
blank(0x2aff)
unused(0x2aff)
unused(0x2af4)
byte(0x2af8, 7)
ab(0x2ad2)
blank(0x2ad4)
ab(0x2ae9)
blank(0x2aea)

stars(0x2b00)
label(0x2b00, "map_address_to_map_xy_position")
label(0x2b15, "map_xy_position_to_map_address")
comment(0x2b2c, "Scrolls the map by setting the tile_map_ptr and visible_top_left_map_x and y")
label(0x2b2c, "update_map_scroll_position")
decimal(0x2b3d)
decimal(0x2b41)
label(0x2b45, "check_for_need_to_scroll_left")
label(0x2b4e, "check_for_need_to_scroll_down")
label(0x2b5e, "check_for_need_to_scroll_up")
label(0x2b67, "check_for_bonus_levels")
comment(0x2b6d, "bonus level is always situated in top left corner", indent=1)
label(0x2b71, "skip_bonus_level")
unused(0x2b85)
label(0x2b90, "wait_for_13_centiseconds_and_read_keys")
label(0x2b92, "wait_for_a_centiseconds_and_read_keys")
label(0x2b94, "wait_for_centiseconds_and_read_keys")
label(0x2b98, "wait_loop")
unused(0x2bc0)

for i in range(0, 9):
    byte(0x2c00+i*4, 4)

blank(0x2c00)
comment(0x2c00, "Sound data packed into single bytes: channel, amplitude, pitch, duration")
label(0x2c00, "in_game_sound_data")
acorn.sound(0x2c24, "in_game_sound_block")
label(0x2c26, "in_game_sound_amplitude")
label(0x2c27, "in_game_sound_amplitude+1")
label(0x2c28, "in_game_sound_pitch")
label(0x2c2a, "in_game_sound_duration")
comment(0x2c2c, "If X is negative, then play sound (X AND 127) with pitch Y.\nIf X is non-negative, play sound X with default pitch.")
label(0x2c2c, "play_sound_x_pitch_y")
label(0x2c31, "skip_using_default_pitch1")
comment(0x2c5c, "use default pitch", indent=1)
comment(0x2c38, "sound 6 also plays sound 7", indent=1)
label(0x2c3d, "play_raw_sound_x_pitch_y")
expr(0x2c4d, "in_game_sound_data+1")
label(0x2c59, "skip_negative_amplitude")
label(0x2c5f, "skip_using_default_pitch2")
expr(0x2c5d, "in_game_sound_data+2")
expr(0x2c63, "in_game_sound_data+3")
unused(0x2c71)
expr(0x2ca6, "in_game_sound_data+2")
unused(0x2cf0)
label(0x2cef, "return9")
comment(0x22fb, "sta $2c16", indent=1)
nonentry(0x22fb)
entry(0x22fe)

expr(0x2736, make_lo("status_bar_sprite_numbers"))

ab(0x2d42)
blank(0x2d44)
label(0x2d44, "return10")
unused(0x2d45)
expr(0x2d51, make_lo("map_row_0-1"))
unused(0x2d81)
label(0x2d90, "fill_with_basics")
comment(0x2d93, "read byte from stage and increment to next byte", indent=1)
label(0x2d9d, "skip_increment_high_byte1")
comment(0x2da1, "The top two bits of the stage byte hold the type to write into the cell. So we shift down six times to get the index, and put the result in X.", indent=1)
comment(0x2da9, "if the index is zero, don't write to the map.", indent=1)
comment(0x2dab, "X=1,2 or 3. Look up the sprite to store in the cell (in the map).", indent=1)
expr(0x2dac, "sprite_for_block_type_1-1")


expr(0x2507, "sprite_for_block_type_1-1")
expr(0x256d, "sprite_for_block_type_1-1")
expr(0x2577, "sprite_for_block_type_1-1")
expr(0x291c, "sprite_for_block_type_1-1")

ab(0x2dbb)
blank(0x2dbd)
unused_entry(0x2dbf)
unused(0x2dca)
comment(0x2dd1, "bmi $2d98", indent=1)
nonentry(0x2dd1)
ab(0x2dd1)
blank(0x2dd3)
unused(0x2dd3)
nonentry(0x2dd3)
byte(0x2de9, 3)

expr(0x2e0b, make_lo("players_and_men_status_bar"))
expr(0x2e13, make_lo("bonus_life_text"))
expr(0x2e1b, make_lo("scrolling_pause_text"))
expr(0x2e80, "sprite_0")
expr(0x2e8a, make_lo("game_over_text"))
expr(0x2e93, "sprite_1")
label(0x2ebf, "play_screen_dissolve_effect")
label(0x2ec9, "screen_dissolve_loop")
unused(0x2ee4)
byte(0x2ee4, 28)

expr(0x2f0a, "sprite_0")
expr(0x2f15, "sprite_0")
expr(0x2f34, "sprite_0")
label(0x2f47, "return11")
unused(0x2f48)
label(0x2f50, "initialise_stage")
label(0x2f59, "empty_status_bar_loop")
expr(0x2f77, "sprite_0")
unused(0x2fdd)

expr(0x301b, "sprite_0")
label(0x302b, "return12")
unused(0x302c)
expr(0x3047, make_lo("pause_message"))
expr(0x3056, make_lo("pause_message"))
expr(0x305e, make_lo("players_and_men_status_bar"))
expr(0x3077, make_lo("out_of_time_message"))
expr(0x30cc, make_lo("status_bar_sprite_numbers"))
label(0x30dc, "return13")
unused(0x30ec)

label(0x3100, "demonstration_keys")
label(0x3160, "demonstration_key_durations")
byte(0x3100, 0x60)
entry(0x31c0, "entry_point")
expr(0x31cc, make_hi("status_bar_sprite_numbers"))
comment(0x31d3, "increment to point to credits text at $3300", indent=1)
expr(0x31d7, make_lo("status_bar_sprite_numbers"))
label(0x31da, "show_credits_loop")
unused(0x31e7)

label(0x3200, "tile_map")
blank(0x3200)
label(0x3200, "status_bar_sprite_numbers")
label(0x3201, "required_diamonds_on_status_bar")
label(0x3203, "total_diamonds_on_status_bar_high_digit")
label(0x3204, "total_diamonds_on_status_bar_low_digit")
label(0x320e, "score_on_status_bar")
label(0x3211, "hundreds_digit_of_score_on_status_bar")
blank(0x3214)
label(0x3214, "players_and_men_status_bar")
label(0x321b, "player_number_on_status_bar")
label(0x321e, "men_number_on_status_bar")
label(0x3225, "cave_letter_on_status_bar")
label(0x3227, "difficulty_level_on_status_bar")
blank(0x3228)
string(0x3225, 1)
blank(0x323c)
expr(0x324d, "'B'")
blank(0x3250)
expr(0x2ab1, make_lo("bonus_life_text"))
label(0x3250, "highscore_high_status_bar")
blank(0x3264)
label(0x3264, "bonus_life_text")
string(0x3264, 1)
string(0x3266, 1)
string(0x3268, 1)
string(0x326a, 1)
string(0x326c, 1)
string(0x3271, 1)
string(0x3273, 1)
string(0x3275, 1)
string(0x3277, 1)
blank(0x3278)
label(0x3278, "number_of_players_status_bar")
label(0x3280, "plural_for_player")
label(0x3289, "cave_letter")
string(0x3289, 1)
label(0x328b, "number_of_players_status_bar_difficulty_level")
blank(0x328c)
label(0x328c, "game_over_text")
label(0x329e, "player_number_on_game_over_text")
label(0x32a0, "scrolling_pause_text")
label(0x32b4, "out_of_time_message")
string(0x32b4, 1)
string(0x32b6, 1)
string(0x32b8, 1)
string(0x32bb, 1)
string(0x32bd, 1)
string(0x32c1, 1)
string(0x32c3, 1)
string(0x32c5, 1)
string(0x32c7, 1)
string(0x32c8, 3)
label(0x32c8, "pause_message")
string(0x32d3, 2)
label(0x32dc, "highscore_last_status_bar")
label(0x32f0, "zeroed_status_bar")

blank(0x3300)
label(0x3300, "copy_of_credits")
comment(0x3300, """
Basic program for debugging purposes. Starts the game.
On startup, this is immediately overwritten by the credits text.

10*KEY 1 MO.4|M PAGE=13056 |M|N
20 MODE 5
30 VDU 23;8202;0;0;0;       (turns off the cursor)
40 *FX 178,0,0              (disables keyboard interrupts)
50 CALL 12736               (start the code at the regular entry_point)
60 *FX 178,255,0            (enables keyboard interrupts)
""")

blank(0x336c)
comment(0x336c, """
A fragment of the original source code (unused).

80 JSR 10829
90 JSR 8850:LDA #220:STA 105
100 LDA #123:LDY #0:JSR 9001
110 JSR 8850:LDA #80:STA 105
120 LDA #125:LDY #128:JSR 9001
130 JSR 8850:LDX

Note there are no hex literals, everything's decimal. Which is unusual.

Translating this to hex form, we see this is the code at &3a06
80 JSR &2A4D
90 JSR &2292:LDA #&DC:STA &69
100 LDA #&7B:LDY #0:JSR &2329
110 JSR &2292:LDA #&50:STA &69
120 LDA #&7D:LDY #&80:JSR &2329
130 JSR &2292:LDX
""")

unused(0x336c)
byte(0x336c, 2)

blank(0x3400)
label(0x3400, "big_rockford_sprite")
byte(0x3400, 6*256)

label(0x3a00, "show_menu")
comment(0x3a09, "show last score line", indent=1)
expr(0x3a0d, make_lo("highscore_last_status_bar"))
expr(0x3a11, make_hi("screen_addr_row_28"))
expr(0x3a13, make_lo("screen_addr_row_28"))
comment(0x3a17, "show highscore line", indent=1)
expr(0x3a1b, make_lo("highscore_high_status_bar"))
expr(0x3a1f, make_hi("screen_addr_row_30"))
expr(0x3a21, make_lo("screen_addr_row_30"))
comment(0x3a25, "store cave letter and difficulty level number")
label(0x3a2c, "handle_menu_loop")
expr(0x3a37, "'A'")
expr(0x3a3d, "sprite_0")
expr(0x3a3e, "sprite_0")
label(0x3a45, "waiting_for_demo_loop")
expr(0x3a46, make_lo("number_of_players_status_bar"))
expr(0x3a61, "opcode_inx")
expr(0x3a9a, "opcode_dex")
label(0x3a99, "move_left_to_change_cave")
label(0x3a9e, "self_modify_move_left_or_right")
label(0x3aa3, "store_new_difficulty_level_selected")
label(0x3aaf, "increase_difficulty_level")
label(0x3ab7, "decrease_difficulty_level")
label(0x3abb, "dont_go_below_one")
label(0x3abe, "toggle_one_or_two_players")
blank(0x3a80)
comment(0x3a80, "demo mode", indent=1)
expr(0x3a83, "sprite_0")
label(0x3a84, "zero_score_on_status_bar_loop")
expr(0x3aca, "'S'")
label(0x3ad1, "show_rockford_again_and_play_game")
label(0x3ae1, "return14")
unused(0x3ae2)

label(0x3b00, "play_game")
expr(0x3b0f, "sprite_2")
expr(0x3b19, "sprite_0")
expr(0x3b33, "sprite_0")
label(0x3b4b, "skip_adding_new_difficulty_level_to_menu")
comment(0x3b48, "add new difficulty level to menu", indent=1)
expr(0x3b71, "sprite_0")
expr(0x3b91, "sprite_0")
expr(0x3b92, "sprite_0")
expr(0x3bc3, "'A'")
expr(0x3bc9, "sprite_0")
unused(0x3bcd)
label(0x3bcc, "return15")

ten_by_four(0x4700, "special_cave_0")
for i in range(0, 24):
    ten_by_four(0x4728+i*40)
blank(0x4ae8)
ten_by_two(0x4ae8)

blank(0x4b00)
label(0x4b00, "diamond_score_before_enough_obtained_for_each_cave")
label(0x4b14, "diamond_score_after_enough_obtained_for_each_cave")
blank(0x4b28)
stars(0x4b00)
label(0x4b28, "required_diamonds_for_each_cave_difficulty_level_1")
blank(0x4b50)
label(0x4b50, "required_diamonds_for_each_cave_difficulty_level_2")
blank(0x4b78)
label(0x4b78, "required_diamonds_for_each_cave_difficulty_level_3")
blank(0x4ba0)
label(0x4ba0, "required_diamonds_for_each_cave_difficulty_level_4")
blank(0x4bc8)
label(0x4bc8, "required_diamonds_for_each_cave_difficulty_level_5")
label(0x4b3c, "time_limit_for_each_cave_difficulty_level_1")
#byte(0x4b3c, 20)
label(0x4b64, "time_limit_for_each_cave_difficulty_level_2")
#byte(0x4b64, 20)
label(0x4b8c, "time_limit_for_each_cave_difficulty_level_3")
#byte(0x4b8c, 20)
label(0x4bb4, "time_limit_for_each_cave_difficulty_level_4")
#byte(0x4bb4, 20)
label(0x4bdc, "time_limit_for_each_cave_difficulty_level_5")
#byte(0x4bdc, 20)
blank(0x4bf0)
for i in range(240):
    decimal(0x4b00+i)
    if (i % 10) == 0:
        byte(0x4b00+i, 10)

label(0x4bf0, "start_y")
ten_by_two(0x4bf0)
label(0x4c04, "start_x")
ten_by_two(0x4c04)
label(0x4c18, "end_y")
ten_by_two(0x4c18)
label(0x4c2c, "end_x")
ten_by_two(0x4c2c)
label(0x4c40, "cave_play_order")
for i in range(20):
    decimal(0x4c40 + i)
    decimal(0x4c54 + i)
ten_by_two(0x4c40)
ten_by_two(0x4c54)
label(0x4c68, "number_of_difficuly_levels_available_for_each_cave")
ten_by_two(0x4c68)
ten_by_two(0x4c7c)
ten_by_two(0x4c90, "lower_nybble_is_initial_cell_for_each_cave")
ten_by_two(0x4ca4, "lower_nybble_is_colour_one_for_each_cave")
ten_by_two(0x4ca4+20*1, "lower_nybble_is_colour_two_for_each_cave")
ten_by_two(0x4ca4+20*2, "lower_nybble_is_colour_three_for_each_cave")
ten_by_two(0x4ca4+20*3, "cave_to_data_set")
stars(0x4cf4)
label(0x4cf4, "data_sets")

label(0x5000, "special_cave_1")
byte(0x5000, 10)
byte(0x5000+10, 10)
byte(0x5000+20, 10)
byte(0x5000+30, 10)
label(0x5028, "backwards_status_bar")
unused(0x503c)
ten_by_four(0x5040, "map_row_0")
label(0x5068, "default_status_bar")
string(0x5079, 1)
blank(0x507c)
unused(0x507c)

ten_by_four(0x5080, "map_row_1")
blank(0x50a8)
unused(0x50a8)

ten_by_four(0x50c0, "map_row_2")
blank(0x50e8)
unused(0x50e8)

ten_by_four(0x5100, "map_row_3")
blank(0x5128)
label(0x5128, "unused_fragment_of_basic1")
byte(0x512c, 4)

ten_by_four(0x5140, "map_row_5")
blank(0x5168)
label(0x5168, "unused_fragment_of_basic2")
byte(0x517b, 5)

ten_by_four(0x5180, "map_row_6")
blank(0x51a8)
unused(0x51a8)
ten_by_four(0x51c0, "map_row_7")
blank(0x51e8)
unused(0x51e8)
ten_by_four(0x5200, "map_row_8")
blank(0x5228)
unused(0x5228)
ten_by_four(0x5240, "map_row_9")
blank(0x5268)
unused(0x5268)
ten_by_four(0x5280, "map_row_10")
blank(0x52a8)
unused(0x52a8)
ten_by_four(0x52c0, "map_row_11")
blank(0x52e8)
unused(0x52e8)
ten_by_four(0x5300, "map_row_12")
blank(0x5328)
unused(0x5328)
ten_by_four(0x5340, "map_row_13")
blank(0x5368)
unused(0x5368)
ten_by_four(0x5380, "map_row_14")
blank(0x53a8)
unused(0x53a8)
ten_by_four(0x53c0, "map_row_15")
blank(0x53e8)
unused(0x53e8)

message(0x5400, 0x5500)

blank(0x5400)
label(0x5400, "credits")

comment(0x5568, "unused copy of routine at $5700")
entry(0x5568)
unused(0x5568)
unused(0x557b)

byte(0x5600, 0xb8)
label(0x5600, "tune_pitches_and_commands")
label(0x573b, "skip_end_of_tune_check")
label(0x574e, "skip_reset_note_repeat")
label(0x56dc, "command_note_durations")
expr(0x5753, "command_note_durations - 200")
decimal(0x573f)
label(0x575c, "note_found")
label(0x561a+200, "command_note_repeat_counts")
expr(0x5749, "command_note_repeat_counts-200")
label(0x560e+200, "command_pitch")
expr(0x574f, "command_pitch-200")
acorn.sound(0x56b8, "sound1")
label(0x56bc, "sound1_pitch")
label(0x56be, "sound1_duration")
acorn.sound(0x56c0, "sound2")
acorn.sound(0x56c8, "sound3")
label(0x56d0, "tune_position_per_channel")
byte(0x56d0, 3)
label(0x56d3, "tune_note_repeat_per_channel")
byte(0x56d3, 3)
label(0x56e8, "tune_start_position_per_channel")
byte(0x56e8, 3)
label(0x56ee, "tune_note_durations_table")
byte(0x56ee, 4)
decimal(0x56ee)
decimal(0x56ef)
decimal(0x56f0)
decimal(0x56f1)
byte(0x56f2, 14)
unused(0x56f2)

label(0x5700, "reset_tune")
label(0x5709, "reset_tune_loop")
label(0x5713, "update_tune")
label(0x5717, "update_channels_loop")
label(0x5777, "skip_increment_tune_position")
expr(0x5784, make_lo("sound1"))
expr(0x5787, make_hi("sound1"))
label(0x578d, "move_to_next_tune_channel")
unused(0x5796)

label(0x5bc0, "start_of_grid_screen_address")
label(0x5800, "big_rockford_destination_screen_address")
label(0x5800 + 6*0x140, "screen_addr_row_6")
label(0x5800 + 28*0x140, "screen_addr_row_28")
label(0x5800 + 30*0x140, "screen_addr_row_30")
acorn.bbc()

print(""";
; Disassembly of Boulderdash, by TobyLobster 2024
; This is a disassembly of the version from http://bbcmicro.co.uk/game.php?id=669
;
; File: ___1___
;
""")

go()
